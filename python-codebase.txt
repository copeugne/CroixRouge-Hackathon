================================================================================
File: backend/__init__.py
Size: 0 B
================================================================================


================================================================================
File: backend/app/back_utils.py
Size: 51 B
================================================================================

def test():
    return "Backend work successfully"


================================================================================
File: backend/app/flashcard_services.py
Size: 12.36 kB
================================================================================

import logging
import json
import os
import time
import random
from typing import List, Dict, Any, Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/flashcards.log", mode='a'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("flashcards")

def analyze_card_difficulty(card_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Analyze flashcards to identify those with poor performance
    
    Args:
        card_data: List of flashcards with review history
        
    Returns:
        List of difficult cards with difficulty scores
    """
    logger.info(f"Analyzing difficulty of {len(card_data)} flashcards")
    
    # Criteria thresholds
    EASE_FACTOR_THRESHOLD = 1.8
    REPETITIONS_THRESHOLD = 2
    
    difficult_cards = []
    
    for card in card_data:
        # Skip cards that haven't been reviewed yet
        if 'last_review' not in card:
            continue
        
        ease_factor = card.get('ease_factor', 2.5)
        repetitions = card.get('repetitions', 0)
        
        # Add to difficult cards if it meets our criteria
        if ease_factor < EASE_FACTOR_THRESHOLD and repetitions > REPETITIONS_THRESHOLD:
            # Create a copy of the card with difficulty metrics
            difficult_card = card.copy()
            difficult_card['difficulty_score'] = calculate_difficulty_score(card)
            difficult_cards.append(difficult_card)
    
    # Sort difficult cards by difficulty score (descending)
    difficult_cards.sort(key=lambda x: x['difficulty_score'], reverse=True)
    
    logger.info(f"Found {len(difficult_cards)} difficult cards")
    return difficult_cards

def calculate_difficulty_score(card: Dict[str, Any]) -> float:
    """
    Calculate a difficulty score for a card based on its study history
    
    Args:
        card: Flashcard data with review history
        
    Returns:
        float: Difficulty score (0-10 scale, higher = more difficult)
    """
    # Base difficulty is inversely related to ease factor
    ease_factor = card.get('ease_factor', 2.5)
    base_difficulty = max(0, (3.0 - ease_factor) / 1.7)  # Normalize to 0-1 range
    
    # Factor in number of repetitions
    repetitions = card.get('repetitions', 0)
    repetition_factor = min(1.0, repetitions / 10.0)  # Normalize, caps at 10 repetitions
    
    # Combined score (0-10 scale)
    score = (base_difficulty * 0.7 + repetition_factor * 0.3) * 10
    
    return round(score, 1)

def generate_related_cards(difficult_cards: List[Dict[str, Any]], 
                           num_to_generate: int = 3,
                           difficulty_level: str = "medium",
                           generation_strategy: str = "related",
                           api_client=None) -> List[Dict[str, Any]]:
    """
    Generate new flashcards using AI based on difficult cards
    
    Args:
        difficult_cards: List of cards identified as difficult
        num_to_generate: Number of new cards to generate
        difficulty_level: Desired difficulty level (easy, medium, hard)
        generation_strategy: Strategy to use (related, breakdown, alternative)
        api_client: Optional API client for Mistral or other LLM
        
    Returns:
        List of generated flashcard dictionaries
    """
    from .services import mistral_client, chat_service
    
    logger.info(f"Generating {num_to_generate} cards using strategy '{generation_strategy}' at '{difficulty_level}' difficulty")
    
    # Extract card content for the prompt
    cards_content = []
    for card in difficult_cards:
        cards_content.append({
            "question": card.get('question', ''),
            "answer": card.get('answer', ''),
            "difficulty_score": card.get('difficulty_score', 5.0)
        })
    
    # Create the generation prompt
    prompt = create_generation_prompt(cards_content, generation_strategy, difficulty_level, num_to_generate)
    
    try:
        # Use the existing chat service (which uses Mistral)
        logger.info("Using chat service to generate cards")
        response = chat_service(prompt)
        
        # Extract the response content
        if isinstance(response, dict) and "response" in response:
            generated_content = response["response"]
        else:
            generated_content = str(response)
        
        # Parse the generated content
        new_cards = parse_ai_response(generated_content)
        
        logger.info(f"Successfully generated {len(new_cards)} cards")
        return new_cards
    
    except Exception as e:
        logger.error(f"Error generating AI flashcards: {str(e)}")
        
        # Return some fallback cards for testing
        logger.warning("Using fallback card generation")
        return generate_fallback_cards(difficult_cards, num_to_generate)

def create_generation_prompt(cards_content: List[Dict[str, Any]], 
                            strategy: str,
                            difficulty: str,
                            num_cards: int) -> str:
    """
    Create a detailed prompt for the AI to generate new flashcards
    
    Args:
        cards_content: List of cards with questions and answers
        strategy: The generation strategy (related, breakdown, alternative)
        difficulty: The desired difficulty level (easy, medium, hard)
        num_cards: Number of cards to generate
        
    Returns:
        str: The formatted prompt for the AI
    """
    cards_text = ""
    for i, card in enumerate(cards_content, 1):
        cards_text += f"Card {i}:\n"
        cards_text += f"Question: {card['question']}\n"
        cards_text += f"Answer: {card['answer']}\n"
        cards_text += f"Difficulty Score: {card['difficulty_score']}/10\n\n"
    
    strategy_descriptions = {
        "related": "Create new flashcards on related topics that will help reinforce the same knowledge",
        "breakdown": "Break down the difficult concepts into simpler, more digestible flashcards",
        "alternative": "Present the same information in alternative ways that might be easier to remember"
    }
    
    difficulty_descriptions = {
        "easy": "Create simpler cards that build foundational knowledge",
        "medium": "Create moderately challenging cards that extend the concepts",
        "hard": "Create advanced cards that deepen understanding of the concepts"
    }
    
    # Build the prompt
    prompt = f"""You are an expert educator and flashcard creator. I'm having difficulty with certain flashcards and need your help to create new ones that will improve my learning.

Here are the flashcards I'm struggling with:

{cards_text}

Please create {num_cards} new flashcards using the following approach:
- Strategy: {strategy} - {strategy_descriptions.get(strategy, "")}
- Difficulty: {difficulty} - {difficulty_descriptions.get(difficulty, "")}

The new flashcards should:
1. Help me better understand and remember the difficult material
2. Follow good flashcard design principles (clear, concise questions with specific answers)
3. Avoid duplicating the exact same cards I already have
4. Be relevant to the subject matter of my difficult cards

Format your response EXACTLY as follows for each new card (and include NOTHING else):

[CARD_START]
QUESTION: (the question for the flashcard)
ANSWER: (the answer for the flashcard)
[CARD_END]

Only include the [CARD_START], QUESTION:, ANSWER:, and [CARD_END] markers - nothing else. Don't include any explanations, introductions or conclusions.
"""
    
    return prompt

def parse_ai_response(response_text: str) -> List[Dict[str, Any]]:
    """
    Parse the AI response into a list of flashcard dictionaries
    
    Args:
        response_text: The text response from the AI
        
    Returns:
        list: List of flashcard dictionaries
    """
    import uuid
    from datetime import datetime
    
    # Initialize empty list
    new_cards = []
    
    # Strip any API prefix
    if response_text.startswith('[API]'):
        response_text = response_text[5:].strip()
    
    # Find all card blocks
    card_blocks = []
    current_block = ""
    in_card = False
    
    for line in response_text.split('\n'):
        stripped_line = line.strip()
        
        if stripped_line == '[CARD_START]':
            in_card = True
            current_block = ""
        elif stripped_line == '[CARD_END]':
            in_card = False
            if current_block.strip():
                card_blocks.append(current_block.strip())
            current_block = ""
        elif in_card:
            current_block += line + "\n"
    
    # Parse each card block
    for block in card_blocks:
        question = ""
        answer = ""
        
        lines = block.split('\n')
        for line in lines:
            if line.startswith('QUESTION:'):
                question = line[len('QUESTION:'):].strip()
            elif line.startswith('ANSWER:'):
                answer = line[len('ANSWER:'):].strip()
        
        if question and answer:
            new_card = {
                'id': str(uuid.uuid4()),
                'title': "",
                'question': question,
                'answer': answer,
                'image_url': "",
                'created_at': datetime.now().isoformat(),
                'tags': ["ai_generated"],
                'repetitions': 0,
                'ease_factor': 2.5,
                'ai_generated': True
            }
            new_cards.append(new_card)
    
    return new_cards

def generate_fallback_cards(difficult_cards: List[Dict[str, Any]], num_to_generate: int = 3) -> List[Dict[str, Any]]:
    """
    Generate fallback cards when AI generation fails
    
    Args:
        difficult_cards: List of difficult cards
        num_to_generate: Number of cards to generate
        
    Returns:
        List of generated card dictionaries
    """
    import uuid
    from datetime import datetime
    
    # Sample templates for different types of cards
    question_templates = [
        "What is the key difference between {concept} and {related_concept}?",
        "How would you explain {concept} to a beginner?",
        "What are the main components of {concept}?",
        "Give an example of {concept} in a real-world context.",
        "What problem does {concept} solve?",
        "What are the limitations of {concept}?",
        "How does {concept} relate to {related_concept}?",
        "What is the opposite of {concept}?",
        "What is a simplified version of {concept}?",
        "If {concept} didn't exist, what would we use instead?"
    ]
    
    # Extract concepts from difficult cards
    concepts = []
    for card in difficult_cards:
        question = card.get('question', '')
        answer = card.get('answer', '')
        
        # Very simple extraction - just get the first few words
        words = question.split()
        if len(words) > 2:
            concepts.append(' '.join(words[:3]))
        else:
            concepts.append(question)
    
    # Generate new cards
    new_cards = []
    for i in range(min(num_to_generate, len(question_templates))):
        # Get a concept and a different related concept
        concept = random.choice(concepts)
        related_concepts = [c for c in concepts if c != concept]
        related_concept = random.choice(related_concepts) if related_concepts else concept
        
        # Create a question from template
        template = question_templates[i % len(question_templates)]
        question = template.format(concept=concept, related_concept=related_concept)
        
        # Create a placeholder answer
        answer = f"This is a placeholder answer about {concept}. In a real implementation, this would be generated by an AI model."
        
        # Create the card
        new_card = {
            'id': str(uuid.uuid4()),
            'title': "",
            'question': question,
            'answer': answer,
            'image_url': "",
            'created_at': datetime.now().isoformat(),
            'tags': ["ai_generated"],
            'repetitions': 0,
            'ease_factor': 2.5,
            'ai_generated': True
        }
        new_cards.append(new_card)
    
    return new_cards

================================================================================
File: backend/app/routes.py
Size: 10.58 kB
================================================================================

from fastapi import FastAPI, APIRouter, Body, File, UploadFile, Form
from fastapi.middleware.cors import CORSMiddleware
from backend.app.services import (
    test_service, 
    chat_service, 
    save_chat_history_service,
    submit_feedback_service,
    update_preferences_service,
    rag_direct_query_service,
    create_collection_service,
    add_document_service,
    get_embeddings_service,
    retrieve_answer_service
)
from backend.app.flashcard_services import (
    analyze_card_difficulty,
    generate_related_cards
)
from settings.config import settings
from pydantic import BaseModel
from typing import List, Optional, Dict, Any


app_router = APIRouter(
    prefix="/api/app",
    tags=["App"],
)

chat_router = APIRouter(
    prefix="/api/chat",
    tags=["Chat"],
)

rag_router = APIRouter(
    prefix="/api/rag",
    tags=["RAG"],
)

flashcard_router = APIRouter(
    prefix="/api/flashcards",
    tags=["Flashcards"],
)

class RAGConfig(BaseModel):
    enabled: bool = False
    collections: List[str] = []
    top_k: int = 3

class MessageRequest(BaseModel):
    message: str
    rag_config: Optional[RAGConfig] = None

class ChatHistoryEntry(BaseModel):
    role: str
    content: str
    timestamp: Optional[str] = None
    
class ChatHistoryRequest(BaseModel):
    history: List[ChatHistoryEntry]
    
class FeedbackRequest(BaseModel):
    message_id: str
    rating: int
    comments: Optional[str] = None
    
class UserPreferences(BaseModel):
    prompt: Dict[str, Any]
    model: Dict[str, Any]
    context: Dict[str, Any]
    rag: Dict[str, Any]
    other: Dict[str, Any]
    
class EmbeddingRequest(BaseModel):
    query: str
    collection_name: str
    
class RetrieveAnswerRequest(BaseModel):
    query: str
    model_family: str
    model_name: str
    prompt: str
    collection_name: str
    history_data: Optional[str] = "[]"

class FlashcardData(BaseModel):
    id: str
    question: str
    answer: str
    title: Optional[str] = ""
    image_url: Optional[str] = ""
    created_at: Optional[str] = None
    tags: Optional[List[str]] = None
    repetitions: Optional[int] = 0
    ease_factor: Optional[float] = 2.5
    last_review: Optional[str] = None
    next_review: Optional[str] = None
    difficulty_score: Optional[float] = None

class AnalyzeFlashcardsRequest(BaseModel):
    cards: List[FlashcardData]

class GenerateFlashcardsRequest(BaseModel):
    difficult_cards: List[FlashcardData]
    num_to_generate: Optional[int] = 3
    difficulty_level: Optional[str] = "medium"
    generation_strategy: Optional[str] = "related"

def create_app(root_path: str = "") -> FastAPI:
    """
    Creating a FastAPI instance and registering routes.

    Args:
        root_path: The root path where the API is mounted (e.g., /username/app_name)
    """

    backend_app = FastAPI(
        title="Chatbot API",
        version="1.0.0",
        openapi_version="3.1.0",
        root_path=root_path
    )

    # CORS Configuration
    backend_app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.ALLOWED_HOSTS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    # Registering routes
    backend_app.include_router(app_router)
    backend_app.include_router(chat_router)
    backend_app.include_router(rag_router)
    backend_app.include_router(flashcard_router)
    return backend_app

@app_router.get("/test/")
async def test():
        return {
            "status:": 200,
            "message": test_service(),
            "data": {
                "title": "here is some example data",
                "genAI_info": {
                    "use_cases": ["Chatbot creation", "Content generation", "Data augmentation",
                                  "Customer support automation"],
                    "key_features": {
                        "personalization": "Generates tailored responses based on user input and context.",
                        "RAG_integration": "Utilizes external knowledge sources to enhance generated responses.",
                        "no_code": "Allows non-technical users to build AI-powered chatbots easily.",
                        "security": "Ensures data privacy with secure integrations and compliance."
                    },
                    "user_examples": [
                        {"name": "John", "use_case": "E-commerce chatbot", "result": "Improved customer engagement by 25%"},
                        {"name": "Sara", "use_case": "Content creation",
                         "result": "Saved 10 hours weekly on content production"}
                    ]
                },
                "additional_metrics": {
                    "response_time_ms": 150,
                    "api_version": "1.0.2"
                }
            }
        }

@chat_router.post("/message/")
async def process_message(request: MessageRequest):
    """
    Process incoming chat messages and return a response
    """
    response_data = chat_service(request.message, request.rag_config)
    # Ensure we return both the response content and metrics
    if isinstance(response_data, dict):
        return response_data
    else:
        # Fallback for backward compatibility if response is just a string
        return {
            "response": response_data,
            "metrics": {
                "input_tokens": 0,
                "output_tokens": 0,
                "total_tokens": 0,
                "response_time": 0
            }
        }

@chat_router.post("/history/save/")
async def save_chat_history(request: ChatHistoryRequest):
    """
    Save the current chat history to the backend
    """
    response = save_chat_history_service(request.history)
    return {"status": "success", "message": response}

@chat_router.post("/feedback/")
async def submit_feedback(request: FeedbackRequest):
    """
    Submit feedback about a specific message/response
    """
    response = submit_feedback_service(request.message_id, request.rating, request.comments)
    return {
        "status": "success", 
        "message": f"Feedback received for message {request.message_id}",
        "data": {
            "rating": request.rating,
            "processed": response
        }
    }

@chat_router.post("/preferences/")
async def update_preferences(preferences: UserPreferences):
    """
    Update user preferences for the chat application
    """
    response = update_preferences_service(preferences.dict())
    return {
        "status": "success",
        "message": "User preferences updated successfully",
        "data": {
            "updated_sections": response
        }
    }

@chat_router.post("/rag/query/")
async def rag_direct_query(query: str = Body(...), collection_name: str = Body(...), top_k: int = Body(3)):
    """
    Send a direct query to the RAG system without generating a response
    Useful for testing and debugging RAG functionality
    """
    response = rag_direct_query_service(query, collection_name, top_k)
    return {
        "status": "success",
        "message": "RAG query processed",
        "data": response
    }

@rag_router.post("/collections/create/")
async def create_collection(name: str = Body(...)):
    """
    Create a new, empty collection in the RAG system
    """
    response = create_collection_service(name)
    return {
        "status": "success",
        "message": f"Collection '{name}' created successfully",
        "data": response
    }

@rag_router.post("/documents/add/")
async def add_document(
    document: UploadFile = File(...),
    collection_name: str = Form(...),
    model: str = Form(...),
    chunk_size: Optional[int] = Form(None),
    chunk_overlap: Optional[int] = Form(None)
):
    """
    Upload a document to a RAG collection
    """
    response = await add_document_service(
        document=document,
        collection_name=collection_name,
        model=model,
        chunk_size=chunk_size,
        chunk_overlap=chunk_overlap
    )
    return {
        "status": "success",
        "message": f"Document '{document.filename}' added successfully to collection '{collection_name}'",
        "data": response
    }

@rag_router.post("/embeddings/")
async def get_embeddings(request: EmbeddingRequest):
    """
    Generate embeddings for a query using the model associated with a collection
    """
    response = get_embeddings_service(request.query, request.collection_name)
    return {
        "status": "success",
        "message": "Embeddings generated successfully",
        "data": response
    }

@rag_router.post("/retrieve-answer/")
async def retrieve_rag_answer(request: RetrieveAnswerRequest):
    """
    Retrieve an answer using RAG system by combining the query with relevant context
    """
    response = retrieve_answer_service(
        query=request.query,
        model_family=request.model_family,
        model_name=request.model_name,
        prompt=request.prompt,
        collection_name=request.collection_name,
        history_data=request.history_data
    )
    return {
        "status": "success",
        "message": "Answer retrieved successfully",
        "data": response
    }

@flashcard_router.post("/analyze/")
async def analyze_flashcards(request: AnalyzeFlashcardsRequest):
    """
    Analyze flashcards to identify difficult ones
    """
    # Convert Pydantic models to dictionaries
    cards_data = [card.dict() for card in request.cards]
    
    # Call the service to analyze difficult cards
    difficult_cards = analyze_card_difficulty(cards_data)
    
    return {
        "status": "success",
        "message": f"Analyzed {len(request.cards)} flashcards, found {len(difficult_cards)} difficult cards",
        "data": {
            "difficult_cards": difficult_cards
        }
    }

@flashcard_router.post("/generate/")
async def generate_flashcards(request: GenerateFlashcardsRequest):
    """
    Generate new flashcards using AI based on difficult cards
    """
    # Convert Pydantic models to dictionaries
    difficult_cards_data = [card.dict() for card in request.difficult_cards]
    
    # Call the service to generate new cards
    generated_cards = generate_related_cards(
        difficult_cards_data,
        num_to_generate=request.num_to_generate,
        difficulty_level=request.difficulty_level,
        generation_strategy=request.generation_strategy
    )
    
    return {
        "status": "success",
        "message": f"Generated {len(generated_cards)} new flashcards",
        "data": {
            "generated_cards": generated_cards
        }
    }


================================================================================
File: backend/app/services.py
Size: 28.81 kB
================================================================================

from backend.app.back_utils import test
import random
import time
import logging
import os
import sys
import json
import uuid
from datetime import datetime
from mistralai import Mistral
from dotenv import load_dotenv, find_dotenv
from rag_api_client import get_document_chunks, retrieve_answer, list_collections
from typing import List, Dict, Any, Optional
from pydantic import BaseModel

# Configure logging with higher level to ensure visibility
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/backend.log", mode='w'),  # Use 'w' mode to create a fresh log
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Configure a separate logger for token usage tracking
token_logger = logging.getLogger("token_usage")
token_logger.setLevel(logging.INFO)
token_handler = logging.FileHandler("logs/tokens.log")
token_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
token_logger.addHandler(token_handler)
# Prevent the token logger from propagating logs to the root logger
token_logger.propagate = False

# LOADING INDICATOR - helps us verify this updated code is running
logger.warning("🔄 LOADING UPDATED SERVICES.PY WITH MISTRAL API, RAG INTEGRATION AND NEW API ENDPOINTS")

# Find and load the .env file
dotenv_path = find_dotenv()
logger.warning(f"📁 Found .env file at: {dotenv_path}")
load_dotenv(dotenv_path)

# In-memory storage for chat histories and feedback - would be replaced with a database in production
chat_histories = {}
user_feedback = {}
user_preferences = {}

# Initialize Mistral client
try:
    # Get the API key directly
    api_key = os.environ.get("MISTRAL_API_KEY")
    
    if not api_key:
        logger.warning("🚫 MISTRAL_API_KEY not found in environment variables. Falling back to rule-based responses.")
        mistral_client = None
    else:
        # Log API key information for debugging (safely)
        key_length = len(api_key)
        key_prefix = api_key[:4] if key_length > 4 else ""
        key_suffix = api_key[-4:] if key_length > 4 else ""
        logger.warning(f"🔑 API key loaded. Length: {key_length}, Prefix: {key_prefix}..., Suffix: ...{key_suffix}")
        
        # Clean the API key (remove any quotes or whitespace)
        api_key = api_key.strip().strip('"\'')
        logger.warning(f"🔑 API key cleaned. New length: {len(api_key)}")
        
        # Initialize the client with the cleaned API key
        mistral_client = Mistral(api_key=api_key)
        logger.warning("✅ Mistral client initialized successfully")
        
        # Test if the client works with a simple query
        try:
            logger.warning("🧪 Testing API connection with a simple query...")
            test_messages = [
                {
                    "role": "system",
                    "content": "Test"
                }
            ]
            # Use stream() method but collect the full response for the test
            stream_response = mistral_client.chat.stream(
                model="mistral-tiny", 
                messages=test_messages
            )
            
            # Collect content from all chunks
            response_content = ""
            for chunk in stream_response:
                if chunk.data.choices[0].delta.content is not None:
                    response_content += chunk.data.choices[0].delta.content
            
            logger.warning(f"✅ API TEST SUCCESS! Response: {response_content[:50]}...")
        except Exception as e:
            logger.error(f"❌ API connection test FAILED: {str(e)}")
            mistral_client = None
            
except Exception as e:
    logger.error(f"❌ Error initializing Mistral client: {str(e)}")
    mistral_client = None

# Model to use - ensure we use tiny model for testing to avoid any access issues
MISTRAL_MODEL = "mistral-tiny"

# Sample responses for fallback
CHATBOT_RESPONSES = {
    "greeting": [
        "Hello! How can I help you today?",
        "Hi there! What can I do for you?",
        "Greetings! How may I assist you?",
        "Hey! How can I be of service today?"
    ],
    "farewell": [
        "Goodbye! Have a great day!",
        "Farewell! Feel free to return if you have more questions.",
        "See you later! Don't hesitate to ask if you need anything else.",
        "Take care! I'm here if you need help again."
    ],
    "thanks": [
        "You're welcome! Is there anything else I can help with?",
        "Happy to help! Let me know if you need anything more.",
        "My pleasure! What else would you like to know?",
        "No problem at all! Feel free to ask more questions."
    ],
    "unknown": [
        "I'm not sure I understand. Could you rephrase that?",
        "Hmm, I'm having trouble processing that request. Can you try again?",
        "I don't have an answer for that yet. Is there something else I can help with?",
        "That's an interesting question. Let me think about how to help you with that."
    ],
    "about": [
        "I'm a modern chatbot designed to help answer your questions!",
        "I'm your friendly AI assistant, ready to chat and help out.",
        "I'm a virtual assistant created to provide information and assistance.",
        "I'm a chatbot built with modern UI/UX principles, focused on providing a great user experience."
    ],
    "capabilities": [
        "I can answer questions, provide information, and have simple conversations.",
        "I'm designed to help with basic queries and provide friendly responses.",
        "I can chat with you about various topics and try to be helpful with your questions.",
        "My main purpose is to demonstrate a modern chatbot interface with good UI/UX design."
    ],
    "features": [
        "This chatbot features a beautiful, modern UI with animated elements and a responsive design.",
        "I come with features like typing indicators, message timestamps, and a clean chat interface.",
        "My design includes custom styling, animations, and an intuitive user experience.",
        "This implementation showcases frontend-backend integration with a FastAPI backend and Streamlit frontend."
    ]
}

class RAGConfig(BaseModel):
    enabled: bool
    collections: List[str]
    top_k: Optional[int] = 3


def test_service():
    return test()


def retrieve_relevant_context(query: str, rag_config: RAGConfig) -> str:
    """
    Retrieve relevant information from RAG collections based on the query
    
    Args:
        query (str): The user's query
        rag_config (RAGConfig): Configuration for RAG retrieval
        
    Returns:
        str: Retrieved context as a formatted string
    """
    if not rag_config or not rag_config.enabled or not rag_config.collections:
        return ""
    
    logger.warning(f"🔍 Retrieving context from RAG collections for query: '{query}'")
    
    collections = rag_config.collections
    top_k = rag_config.top_k
    
    # Placeholder for all retrieved contexts
    retrieved_contexts = []
    context_str = ""
    
    try:
        for collection in collections:
            logger.warning(f"🔍 Searching in collection: {collection}")
            
            # Get documents from collection (this is a simplified approach)
            # In a real implementation, you would use semantic search here
            # For now, we'll just get some document chunks to simulate the process
            response = get_document_chunks(
                collection_name=collection, 
                document_path=query,  # Using the query as a placeholder document path
                limit=top_k
            )
            
            # Extract chunks from response
            if isinstance(response, dict) and "chunks" in response:
                chunks = response.get("chunks", [])
                for chunk in chunks:
                    retrieved_contexts.append({
                        "collection": collection,
                        "text": chunk
                    })
                    
        # Format the retrieved context into a string
        if retrieved_contexts:
            context_str = "Here's some relevant information that may help you answer:\n\n"
            for i, ctx in enumerate(retrieved_contexts, 1):
                collection_name = ctx["collection"]
                text = ctx["text"]
                context_str += f"Source {i} ({collection_name}):\n{text}\n\n"
        
        logger.warning(f"📚 Retrieved {len(retrieved_contexts)} context chunks")
        return context_str
    
    except Exception as e:
        logger.error(f"❌ Error retrieving context: {str(e)}")
        return ""


def chat_service(message, rag_config=None):
    """
    Process a user message and generate a response using Mistral AI
    
    Args:
        message (str): The user's message
        rag_config (RAGConfig, optional): Configuration for RAG retrieval
        
    Returns:
        str: The chatbot's response
    """
    logger.warning(f"📩 Received message: '{message}'")
    
    # Start timing the response
    start_time = time.time()
    
    # Generate a message ID for tracking and feedback
    message_id = str(uuid.uuid4())
    
    # Retrieve relevant context if RAG is enabled
    context = ""
    if rag_config and rag_config.enabled:
        context = retrieve_relevant_context(message, rag_config)
        if context:
            logger.warning(f"📚 Retrieved context: '{context[:100]}...'")
    
    # Use Mistral API if available
    if mistral_client:
        try:
            logger.warning(f"🤖 Using MISTRAL API to generate response")
            
            # Create system prompt with RAG context if available
            system_prompt = "You are a helpful and friendly assistant. Your responses should be concise, informative, and engaging. You're part of a modern chatbot interface demo."
            if context:
                system_prompt += "\n\nUse the following information to help answer the user's question:\n\n" + context
            
            messages = [
                {
                    "role": "system", 
                    "content": system_prompt
                },
                {
                    "role": "user", 
                    "content": message
                }
            ]
            
            logger.warning(f"📤 Sending request to model: {MISTRAL_MODEL}")
            
            # Get the streaming response
            stream_response = mistral_client.chat.stream(
                model=MISTRAL_MODEL,
                messages=messages
            )
            
            # Collect content from all chunks
            response_content = ""
            for chunk in stream_response:
                if chunk.data.choices[0].delta.content is not None:
                    response_content += chunk.data.choices[0].delta.content
            
            # Add API prefix to the response if not already there
            if not response_content.startswith('[API]'):
                response_content = "[API] " + response_content
            
            logger.warning(f"📥 Got Mistral API streaming response: {response_content[:50]}...")
            
            # Calculate response time
            response_time = time.time() - start_time
            
            # Estimate token counts (rough approximation)
            input_tokens = len(system_prompt + "\n\n" + message) // 4
            output_tokens = len(response_content) // 4
            total_tokens = input_tokens + output_tokens
            
            # Log AI request details
            log_ai_request(
                model=MISTRAL_MODEL,
                input_text=system_prompt + "\n\n" + message,
                output_text=response_content,
                rag_used=bool(rag_config and rag_config.enabled),
                rag_collections=rag_config.collections if rag_config and rag_config.enabled else None
            )
            
            # Return response with token and time information
            return {
                "response": response_content,
                "metrics": {
                    "input_tokens": input_tokens,
                    "output_tokens": output_tokens,
                    "total_tokens": total_tokens,
                    "response_time": round(response_time, 2)
                }
            }
        
        except Exception as e:
            logger.error(f"❌ Error calling Mistral API: {str(e)}")
            logger.warning("⚠️ Falling back to rule-based responses")
            
            # Calculate response time even for fallback
            response_time = time.time() - start_time
            fallback_response = "[FALLBACK] Sorry, I couldn't connect to my AI brain. " + get_fallback_response(message)
            
            return {
                "response": fallback_response,
                "metrics": {
                    "input_tokens": 0,
                    "output_tokens": 0,
                    "total_tokens": 0,
                    "response_time": round(response_time, 2)
                }
            }
    
    # Fallback to rule-based responses if Mistral is not available
    logger.warning("⚠️ Using fallback rule-based responses (Mistral client not available)")
    
    # Calculate response time for fallback
    response_time = time.time() - start_time
    fallback_response = "[FALLBACK] " + get_fallback_response(message)
    
    return {
        "response": fallback_response,
        "metrics": {
            "input_tokens": 0,
            "output_tokens": 0,
            "total_tokens": 0,
            "response_time": round(response_time, 2)
        }
    }

def get_fallback_response(message):
    """Get a fallback response when the API is not available"""
    # Simulate processing time
    time.sleep(0.2)
    
    message_lower = message.lower().strip()
    
    # Very simple response logic based on keywords
    if any(word in message_lower for word in ["hi", "hello", "hey", "greetings"]):
        response_type = "greeting"
    elif any(word in message_lower for word in ["bye", "goodbye", "farewell", "see you"]):
        response_type = "farewell"
    elif any(word in message_lower for word in ["thanks", "thank you", "appreciate"]):
        response_type = "thanks"
    elif any(word in message_lower for word in ["who are you", "what are you", "about you"]):
        response_type = "about"
    elif any(word in message_lower for word in ["can you", "able to", "capabilities"]):
        response_type = "capabilities"
    elif any(word in message_lower for word in ["features", "design", "interface", "ui"]):
        response_type = "features"
    else:
        # If we detect a question but don't have a specific category
        if "?" in message or any(word in message_lower for word in ["what", "how", "why", "where", "when", "who"]):
            # For questions we don't have explicit answers for
            if "weather" in message_lower:
                return "I'm not connected to weather services, but I hope it's nice outside!"
            elif "time" in message_lower:
                return f"I don't have access to the current time, but it's always a good time to chat!"
            elif "name" in message_lower:
                return "You can call me Modern Chatbot. What's your name?"
            else:
                response_type = "unknown"
        else:
            # For statements or commands
            response_type = "unknown"
    
    # Select a random response from the appropriate category
    response = random.choice(CHATBOT_RESPONSES[response_type])
    
    logger.warning(f"📝 Responding with fallback: {response}")
    return response

def save_chat_history_service(history_data):
    """
    Save chat history to storage (in-memory for now, would be a database in production)
    
    Args:
        history_data: List of chat history entries
        
    Returns:
        dict: Status of the operation
    """
    try:
        # Generate a unique ID for this chat history
        chat_id = str(uuid.uuid4())
        
        # Store the history with a timestamp
        chat_histories[chat_id] = {
            "history": history_data,
            "timestamp": datetime.now().isoformat(),
        }
        
        logger.info(f"💾 Saved chat history with ID: {chat_id}")
        return {
            "status": "success",
            "chat_id": chat_id,
            "message": "Chat history saved successfully"
        }
    except Exception as e:
        logger.error(f"❌ Error saving chat history: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to save chat history: {str(e)}"
        }

def submit_feedback_service(message_id, rating, comments=None):
    """
    Store feedback about a specific message/response
    
    Args:
        message_id: Unique identifier for the message
        rating: Numeric rating (typically 1-5)
        comments: Optional feedback comments
        
    Returns:
        dict: Status of the operation
    """
    try:
        # Store the feedback
        user_feedback[message_id] = {
            "rating": rating,
            "comments": comments,
            "timestamp": datetime.now().isoformat()
        }
        
        logger.info(f"📊 Received feedback for message {message_id}: {rating}/5")
        return {
            "status": "success",
            "message": "Feedback recorded successfully",
            "data": {
                "message_id": message_id,
                "processed": True
            }
        }
    except Exception as e:
        logger.error(f"❌ Error recording feedback: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to record feedback: {str(e)}"
        }

def update_preferences_service(preferences_data):
    """
    Update and store user preferences
    
    Args:
        preferences_data: Dictionary containing user preferences
        
    Returns:
        dict: Status of the operation
    """
    try:
        # Generate a user ID (in a real app, this would be tied to user authentication)
        user_id = "default_user"  # Simplified for this demo
        
        # Store or update the preferences
        if user_id not in user_preferences:
            user_preferences[user_id] = {}
        
        # Update each section of preferences
        for section, data in preferences_data.items():
            user_preferences[user_id][section] = data
        
        logger.info(f"⚙️ Updated preferences for user: {user_id}")
        return {
            "status": "success",
            "message": "Preferences updated successfully",
            "data": {
                "user_id": user_id,
                "updated_sections": list(preferences_data.keys())
            }
        }
    except Exception as e:
        logger.error(f"❌ Error updating preferences: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to update preferences: {str(e)}"
        }

def rag_direct_query_service(query, collection_name, top_k=3):
    """
    Perform a direct RAG query without generating a response
    
    Args:
        query: The search query
        collection_name: Name of the collection to search
        top_k: Number of results to return
        
    Returns:
        dict: Query results
    """
    try:
        logger.info(f"🔍 Processing direct RAG query: '{query}' in collection '{collection_name}'")
        
        # Get document chunks
        response = get_document_chunks(
            collection_name=collection_name,
            document_path=query,  # Using the query as a document path (this is simplified)
            limit=top_k
        )
        
        # Extract chunks from response
        chunks = []
        if isinstance(response, dict) and "chunks" in response:
            chunks = response.get("chunks", [])
        
        logger.info(f"📚 Retrieved {len(chunks)} chunks for query")
        return {
            "status": "success",
            "message": "RAG query processed successfully",
            "data": {
                "query": query,
                "collection": collection_name,
                "top_k": top_k,
                "chunks": chunks
            }
        }
    except Exception as e:
        logger.error(f"❌ Error processing RAG query: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to process RAG query: {str(e)}"
        }

def create_collection_service(collection_name: str) -> dict:
    """
    Create a new RAG collection
    
    Args:
        collection_name (str): Name for the new collection
        
    Returns:
        dict: API response with creation status
    """
    try:
        from rag_api_client import create_collection
        
        logger.info(f"🗂️ Creating new collection: '{collection_name}'")
        response = create_collection(collection_name)
        logger.info(f"✅ Collection created successfully: {collection_name}")
        return response
    except Exception as e:
        logger.error(f"❌ Error creating collection: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to create collection: {str(e)}"
        }

async def add_document_service(document, collection_name: str, model: str, chunk_size=None, chunk_overlap=None) -> dict:
    """
    Add a document to a RAG collection
    
    Args:
        document: UploadFile object containing the document
        collection_name (str): Collection to add document to
        model (str): Embedding model to use
        chunk_size (int, optional): Size of text chunks
        chunk_overlap (int, optional): Overlap between chunks
        
    Returns:
        dict: API response with addition status
    """
    import tempfile
    import os
    from rag_api_client import add_document
    
    try:
        # Get API key from environment
        api_key = os.environ.get("MISTRAL_API_KEY")
        if not api_key:
            raise ValueError("Missing API key for document embedding")
        
        # Save uploaded file to temp file
        with tempfile.NamedTemporaryFile(delete=False, suffix=f"_{document.filename}") as tmp:
            content = await document.read()
            tmp.write(content)
            tmp_path = tmp.name
        
        logger.info(f"📄 Adding document '{document.filename}' to collection '{collection_name}'")
        
        # Call RAG API to add document
        response = add_document(
            file_path=tmp_path,
            collection_name=collection_name,
            model=model,
            api_key=api_key,
            chunk_size=chunk_size,
            chunk_overlap=chunk_overlap
        )
        
        # Clean up temp file
        os.unlink(tmp_path)
        
        logger.info(f"✅ Document added successfully: '{document.filename}'")
        return response
    
    except Exception as e:
        logger.error(f"❌ Error adding document: {str(e)}")
        # Ensure temp file is cleaned up in case of error
        try:
            if 'tmp_path' in locals():
                os.unlink(tmp_path)
        except:
            pass
            
        return {
            "status": "error",
            "message": f"Failed to add document: {str(e)}"
        }

def get_embeddings_service(query: str, collection_name: str) -> dict:
    """
    Generate embeddings for a text query
    
    Args:
        query (str): Text to embed
        collection_name (str): Collection determining the embedding model
        
    Returns:
        dict: Embedding vector
    """
    try:
        import os
        from rag_api_client import get_embeddings
        
        # Get API key from environment
        api_key = os.environ.get("MISTRAL_API_KEY")
        if not api_key:
            raise ValueError("Missing API key for generating embeddings")
        
        logger.info(f"🧠 Generating embeddings for query in collection '{collection_name}'")
        
        response = get_embeddings(
            query=query,
            collection_name=collection_name,
            api_key=api_key
        )
        
        # Log success without printing the entire embedding vector
        if "embedding" in response and isinstance(response["embedding"], list):
            embedding_len = len(response["embedding"])
            logger.info(f"✅ Embeddings generated successfully: {embedding_len} dimensions")
        else:
            logger.info("✅ Response received but no embedding found in response")
            
        return response
    except Exception as e:
        logger.error(f"❌ Error generating embeddings: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to generate embeddings: {str(e)}"
        }

def retrieve_answer_service(query: str, model_family: str, model_name: str, 
                           prompt: str, collection_name: str, history_data: str = "[]") -> dict:
    """
    Use RAG to retrieve an answer to a query
    
    Args:
        query (str): User's question
        model_family (str): The LLM provider family (mistral, openai, etc.)
        model_name (str): Specific model to use
        prompt (str): System prompt template
        collection_name (str): Knowledge base to query
        history_data (str, optional): JSON string of conversation history
        
    Returns:
        dict: Generated answer and metadata
    """
    try:
        import os
        from rag_api_client import retrieve_answer
        
        # Get API key from environment
        api_key = os.environ.get("MISTRAL_API_KEY")
        if not api_key:
            raise ValueError("Missing API key for LLM inference")
        
        logger.info(f"🔍 Retrieving RAG answer using {model_family}/{model_name}")
        logger.info(f"📚 Using collection: {collection_name}")
        
        response = retrieve_answer(
            query=query,
            model_family=model_family,
            model_name=model_name,
            api_key=api_key,
            prompt=prompt,
            collection_name=collection_name,
            history_data=history_data
        )
        
        # Log a snippet of the answer
        if "answer" in response:
            answer_snippet = response["answer"][:100] + "..." if len(response["answer"]) > 100 else response["answer"]
            logger.info(f"✅ Answer retrieved: {answer_snippet}")
            
            # Log the AI request details for RAG
            log_ai_request(
                model=f"{model_family}/{model_name}",
                input_text=query,
                output_text=response["answer"],
                rag_used=True,
                rag_collections=[collection_name]
            )
        else:
            logger.info("✅ Response received but no answer found in response")
            
        return response
    except Exception as e:
        logger.error(f"❌ Error retrieving answer: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to retrieve answer: {str(e)}"
        }

def log_ai_request(model: str, input_text: str, output_text: str, rag_used: bool = False, rag_collections: List[str] = None):
    """
    Log AI request details to a separate log file
    
    Args:
        model (str): The model name used for generation
        input_text (str): The input text (for token count estimation)
        output_text (str): The output text (for token count estimation)
        rag_used (bool): Whether RAG was used for this request
        rag_collections (List[str], optional): List of collections used for RAG
    """
    try:
        # Estimate token counts (actual implementation would use model tokenizer)
        # Using rough approximation: ~4 chars per token for English text
        input_tokens = len(input_text) // 4
        output_tokens = len(output_text) // 4
        total_tokens = input_tokens + output_tokens
        
        # Format the log message
        timestamp = datetime.now().isoformat()
        rag_info = f"RAG: {rag_used}, Collections: {rag_collections if rag_collections else []}"
        
        log_message = f"Model: {model}, Input tokens: {input_tokens}, Output tokens: {output_tokens}, " \
                     f"Total tokens: {total_tokens}, {rag_info}"
        
        # Log the details
        token_logger.info(log_message)
        
        # Regular log for debugging
        logger.info(f"📊 Logged AI request: {model}, {input_tokens} -> {output_tokens} tokens, RAG: {rag_used}")
        
    except Exception as e:
        logger.error(f"❌ Error logging AI request: {str(e)}")


================================================================================
File: flashcard_stats.json
Size: 158 B
================================================================================

{
  "studied_today": 10,
  "total_studied": 10,
  "correct_today": 3,
  "total_correct": 3,
  "streak": 0,
  "last_study_date": "2025-04-05T16:17:30.681638"
}

================================================================================
File: flashcards.json
Size: 2.21 kB
================================================================================

[
  {
    "id": "ed5969c9-3a6a-464e-a8b8-4c72be00c9e0",
    "title": "Hemorragie Externe",
    "question": "Test",
    "answer": "Test",
    "image_url": "https://files.catbox.moe/6ki23x.png",
    "created_at": "2025-04-05T14:52:22.437953",
    "tags": [],
    "repetitions": 1,
    "ease_factor": 2.35,
    "interval": 1,
    "next_review": "2025-04-06T16:17:13.978356",
    "last_review": "2025-04-05T16:17:13.978370"
  },
  {
    "id": "26921516-5c1a-4179-942c-86565c5bb65e",
    "title": "Brulure Grave",
    "question": "Comment traiter une brulure grave ?",
    "answer": "Refroidir imm\u00e9diatement sous l'eau froide pendant au moins 20 minutes, ne jamais retirer les v\u00eatements coll\u00e9s \u00e0 la peau et couvrir la br\u00fblure avec un pansement st\u00e9rile.",
    "image_url": "https://files.catbox.moe/n5k9cy.png",
    "created_at": "2025-04-05T16:14:25.550976",
    "tags": [],
    "repetitions": 0,
    "ease_factor": 2.5,
    "interval": 1,
    "next_review": "2025-04-06T16:17:27.010735",
    "last_review": "2025-04-05T16:17:27.010750"
  },
  {
    "id": "72ac7d19-bb15-4bb1-962b-b7c1acad7e00",
    "title": "Perte de conscience",
    "question": "Comment savoir si une personne a perdu conscience ?",
    "answer": "V\u00e9rifier si la personne r\u00e9agit \u00e0 un stimulus (comme secouer doucement l'\u00e9paule), v\u00e9rifier la respiration et la r\u00e9activit\u00e9 des pupilles.",
    "image_url": "",
    "created_at": "2025-04-05T16:15:39.330584",
    "tags": [],
    "repetitions": 1,
    "ease_factor": 2.35,
    "interval": 1,
    "next_review": "2025-04-06T16:17:30.681595",
    "last_review": "2025-04-05T16:17:30.681611"
  },
  {
    "id": "b0d43f68-ff64-4c6f-b7ad-0e15d897e0b2",
    "title": "RCP",
    "question": "Quelles sont les \u00e9tapes de la r\u00e9animation cardio-pulmonaire (RCP) ?",
    "answer": "V\u00e9rifier la s\u00e9curit\u00e9 de la sc\u00e8ne, v\u00e9rifier la respiration, pratiquer des compressions thoraciques \u00e0 un rythme de 100 \u00e0 120 par minute, et utiliser un d\u00e9fibrillateur si disponible.",
    "image_url": "",
    "created_at": "2025-04-05T16:16:44.774675",
    "tags": [],
    "repetitions": 0,
    "ease_factor": 2.5
  }
]

================================================================================
File: frontend/flashcard_ai.py
Size: 27.64 kB
================================================================================

import streamlit as st
import json
import time
from datetime import datetime
import random
import uuid
from pathlib import Path
import requests
import os
from typing import List, Dict, Any, Optional

# Get environment variables
from dotenv import load_dotenv
load_dotenv(".client_env")
DOMAIN_NAME = os.getenv("DOMAIN_NAME", "localhost")
ROOT_PATH = os.getenv("ROOT_PATH", "")
BACKEND_PORT = os.getenv("BACKEND_PORT", "8090")

# Initialize AI-related session state variables
def init_flashcard_ai_state():
    """Initialize AI-related session state variables for flashcards"""
    if "difficult_cards" not in st.session_state:
        st.session_state.difficult_cards = []
    
    if "ai_generated_cards" not in st.session_state:
        st.session_state.ai_generated_cards = []
    
    if "selected_difficult_cards" not in st.session_state:
        st.session_state.selected_difficult_cards = []
    
    if "generation_in_progress" not in st.session_state:
        st.session_state.generation_in_progress = False
    
    if "show_select_cards" not in st.session_state:
        st.session_state.show_select_cards = False
    
    # AI settings - load from file if available
    if "ai_settings" not in st.session_state:
        # Default settings
        default_ai_settings = {
            "num_cards_to_generate": 3,
            "generation_strategy": "related",  # 'related', 'breakdown', 'alternative'
            "difficulty_level": "medium"       # 'easy', 'medium', 'hard'
        }
        
        # Try to load settings from file
        settings_file = Path("flashcard_ai_settings.json")
        if settings_file.exists():
            try:
                with open(settings_file, "r") as f:
                    st.session_state.ai_settings = json.load(f)
            except Exception as e:
                print(f"Failed to load AI settings: {e}")
                st.session_state.ai_settings = default_ai_settings
        else:
            st.session_state.ai_settings = default_ai_settings

def analyze_difficult_cards():
    """
    Analyze flashcards to identify those with poor performance
    
    This function finds cards that:
    1. Have low ease factors (< 1.8)
    2. Have been reviewed multiple times (repetitions > 2)
    3. Have been consistently rated as 'Again' or 'Hard'
    """
    # Reset difficult cards list
    st.session_state.difficult_cards = []
    
    # Criteria thresholds
    EASE_FACTOR_THRESHOLD = 1.8
    REPETITIONS_THRESHOLD = 2
    
    # Analyze each card
    for card in st.session_state.flashcards:
        # Skip cards that haven't been reviewed yet
        if 'last_review' not in card:
            continue
        
        ease_factor = card.get('ease_factor', 2.5)
        repetitions = card.get('repetitions', 0)
        
        # Add to difficult cards if it meets our criteria
        if ease_factor < EASE_FACTOR_THRESHOLD and repetitions > REPETITIONS_THRESHOLD:
            # Create a copy of the card with difficulty metrics
            difficult_card = card.copy()
            difficult_card['difficulty_score'] = calculate_difficulty_score(card)
            difficult_card['selected'] = False
            st.session_state.difficult_cards.append(difficult_card)
    
    # Sort difficult cards by difficulty score (descending)
    st.session_state.difficult_cards.sort(key=lambda x: x['difficulty_score'], reverse=True)
    
    return st.session_state.difficult_cards

def calculate_difficulty_score(card):
    """
    Calculate a difficulty score for a card based on its study history
    
    Higher score = more difficult
    """
    # Base difficulty is inversely related to ease factor
    ease_factor = card.get('ease_factor', 2.5)
    base_difficulty = max(0, (3.0 - ease_factor) / 1.7)  # Normalize to 0-1 range
    
    # Factor in number of repetitions
    repetitions = card.get('repetitions', 0)
    repetition_factor = min(1.0, repetitions / 10.0)  # Normalize, caps at 10 repetitions
    
    # Combined score (0-10 scale)
    score = (base_difficulty * 0.7 + repetition_factor * 0.3) * 10
    
    return round(score, 1)

def toggle_card_selection(card_id):
    """Toggle the selection status of a difficult card"""
    for card in st.session_state.difficult_cards:
        if card['id'] == card_id:
            card['selected'] = not card['selected']
            break
    
    # Update selected cards list
    st.session_state.selected_difficult_cards = [
        card for card in st.session_state.difficult_cards if card.get('selected', False)
    ]

def generate_ai_flashcards(selected_cards=None):
    """
    Generate new flashcards using AI based on selected difficult cards
    
    Args:
        selected_cards: List of cards to use as the basis for generation
    """
    if not selected_cards:
        selected_cards = st.session_state.selected_difficult_cards
    
    if not selected_cards:
        return {"status": "error", "message": "No cards selected for AI generation"}
    
    try:
        # Set the generation in progress flag
        st.session_state.generation_in_progress = True
        
        # Get generation settings from session state
        strategy = st.session_state.ai_settings.get('generation_strategy', 'related')
        difficulty = st.session_state.ai_settings.get('difficulty_level', 'medium')
        num_cards = st.session_state.ai_settings.get('num_cards_to_generate', 3)
        
        # First try to use the backend API for flashcard generation
        try:
            from frontend.middleware import generate_ai_flashcards as api_generate_flashcards
            
            # Call the dedicated API endpoint
            result = api_generate_flashcards(
                selected_cards,
                num_to_generate=num_cards,
                difficulty_level=difficulty,
                generation_strategy=strategy
            )
            
            if isinstance(result, dict) and "generated_cards" in result:
                # Success! Use the cards from the API
                new_cards = result["generated_cards"]
                st.session_state.ai_generated_cards = new_cards
                
                return {
                    "status": "success",
                    "message": f"Generated {len(new_cards)} new flashcards using backend AI",
                    "cards": new_cards
                }
        except Exception as api_error:
            # If API call fails, fall back to the chat-based method
            print(f"API generation failed, falling back to chat: {str(api_error)}")
        
        # Fallback method using the chat API
        # Prepare the API request
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/chat/message/"
        
        # Extract card content for the prompt
        cards_content = []
        for card in selected_cards:
            cards_content.append({
                "question": card['question'],
                "answer": card['answer'],
                "difficulty_score": card.get('difficulty_score', 5.0)
            })
        
        prompt = create_generation_prompt(cards_content, strategy, difficulty, num_cards)
        
        # Send the request to the backend
        payload = {
            "message": prompt,
            "rag_config": {
                "enabled": False
            }
        }
        
        response = requests.post(url, json=payload)
        
        if response.status_code == 200:
            response_data = response.json()
            generated_content = response_data.get("response", "")
            
            # Parse the generated content into flashcards
            new_cards = parse_ai_response(generated_content)
            
            # Add the new cards to the session state
            st.session_state.ai_generated_cards = new_cards
            
            return {
                "status": "success",
                "message": f"Generated {len(new_cards)} new flashcards",
                "cards": new_cards
            }
        else:
            return {
                "status": "error",
                "message": f"Error generating flashcards: {response.status_code}"
            }
    except Exception as e:
        return {
            "status": "error",
            "message": f"Error generating flashcards: {str(e)}"
        }
    finally:
        # Clear the generation in progress flag
        st.session_state.generation_in_progress = False

def create_generation_prompt(cards_content, strategy, difficulty, num_cards):
    """
    Create a detailed prompt for the AI to generate new flashcards
    
    Args:
        cards_content: List of cards with questions and answers
        strategy: The generation strategy (related, breakdown, alternative)
        difficulty: The desired difficulty level (easy, medium, hard)
        num_cards: Number of cards to generate
        
    Returns:
        str: The formatted prompt for the AI
    """
    cards_text = ""
    for i, card in enumerate(cards_content, 1):
        cards_text += f"Card {i}:\n"
        cards_text += f"Question: {card['question']}\n"
        cards_text += f"Answer: {card['answer']}\n"
        cards_text += f"Difficulty Score: {card['difficulty_score']}/10\n\n"
    
    strategy_descriptions = {
        "related": "Create new flashcards on related topics that will help reinforce the same knowledge",
        "breakdown": "Break down the difficult concepts into simpler, more digestible flashcards",
        "alternative": "Present the same information in alternative ways that might be easier to remember"
    }
    
    difficulty_descriptions = {
        "easy": "Create simpler cards that build foundational knowledge",
        "medium": "Create moderately challenging cards that extend the concepts",
        "hard": "Create advanced cards that deepen understanding of the concepts"
    }
    
    # Build the prompt
    prompt = f"""You are an expert educator and flashcard creator. I'm having difficulty with certain flashcards and need your help to create new ones that will improve my learning.

Here are the flashcards I'm struggling with:

{cards_text}

Please create {num_cards} new flashcards using the following approach:
- Strategy: {strategy} - {strategy_descriptions.get(strategy, "")}
- Difficulty: {difficulty} - {difficulty_descriptions.get(difficulty, "")}

The new flashcards should:
1. Help me better understand and remember the difficult material
2. Follow good flashcard design principles (clear, concise questions with specific answers)
3. Avoid duplicating the exact same cards I already have
4. Be relevant to the subject matter of my difficult cards

Format your response EXACTLY as follows for each new card (and include NOTHING else):

[CARD_START]
QUESTION: (the question for the flashcard)
ANSWER: (the answer for the flashcard)
[CARD_END]

Only include the [CARD_START], QUESTION:, ANSWER:, and [CARD_END] markers - nothing else. Don't include any explanations, introductions or conclusions.
"""
    
    return prompt

def parse_ai_response(response_text):
    """
    Parse the AI response into a list of flashcard dictionaries
    
    Args:
        response_text: The text response from the AI
        
    Returns:
        list: List of flashcard dictionaries
    """
    # Initialize empty list
    new_cards = []
    
    # Strip any API prefix
    if response_text.startswith('[API]'):
        response_text = response_text[5:].strip()
    
    # Find all card blocks
    card_blocks = []
    current_block = ""
    in_card = False
    
    for line in response_text.split('\n'):
        stripped_line = line.strip()
        
        if stripped_line == '[CARD_START]':
            in_card = True
            current_block = ""
        elif stripped_line == '[CARD_END]':
            in_card = False
            if current_block.strip():
                card_blocks.append(current_block.strip())
            current_block = ""
        elif in_card:
            current_block += line + "\n"
    
    # Parse each card block
    for block in card_blocks:
        question = ""
        answer = ""
        
        lines = block.split('\n')
        for line in lines:
            if line.startswith('QUESTION:'):
                question = line[len('QUESTION:'):].strip()
            elif line.startswith('ANSWER:'):
                answer = line[len('ANSWER:'):].strip()
        
        if question and answer:
            new_card = {
                'id': str(uuid.uuid4()),
                'title': "",
                'question': question,
                'answer': answer,
                'image_url': "",
                'created_at': datetime.now().isoformat(),
                'tags': ["ai_generated"],
                'repetitions': 0,
                'ease_factor': 2.5,
                'ai_generated': True
            }
            new_cards.append(new_card)
    
    return new_cards

def save_ai_settings():
    """Save AI assistant settings to file"""
    try:
        with open("flashcard_ai_settings.json", "w") as f:
            json.dump(st.session_state.ai_settings, f, indent=2)
        return {"status": "success", "message": "AI settings saved successfully"}
    except Exception as e:
        st.error(f"Failed to save AI settings: {e}")
        return {"status": "error", "message": f"Failed to save AI settings: {str(e)}"}

def save_ai_generated_cards():
    """Save the AI-generated cards to the main flashcards list"""
    if not st.session_state.ai_generated_cards:
        return {"status": "error", "message": "No AI-generated cards to save"}
    
    # Add the generated cards to the main flashcards list
    st.session_state.flashcards.extend(st.session_state.ai_generated_cards)
    
    # Save to disk if auto-save is enabled
    if st.session_state.flashcard_settings['auto_save']:
        try:
            with open("flashcards.json", "w") as f:
                json.dump(st.session_state.flashcards, f, indent=2)
                
            # Reset the generated cards list
            ai_cards_count = len(st.session_state.ai_generated_cards)
            st.session_state.ai_generated_cards = []
            
            return {
                "status": "success", 
                "message": f"Saved {ai_cards_count} AI-generated flashcards"
            }
        except Exception as e:
            return {"status": "error", "message": f"Failed to save flashcards: {str(e)}"}
    else:
        # Just note that they've been added to memory
        ai_cards_count = len(st.session_state.ai_generated_cards)
        st.session_state.ai_generated_cards = []
        
        return {
            "status": "success", 
            "message": f"Added {ai_cards_count} AI-generated flashcards (not yet saved to disk)"
        }

def apply_custom_ai_css():
    """Apply custom CSS for the AI flashcard interface"""
    st.markdown("""
    <style>
    /* Card difficulty indicator */
    .difficulty-indicator {
        font-size: 0.8rem;
        padding: 4px 8px;
        border-radius: 10px;
        font-weight: bold;
        margin-left: 10px;
    }
    
    .difficulty-high {
        background-color: #ffcccc;
        color: #cc0000;
    }
    
    .difficulty-medium {
        background-color: #fff2cc;
        color: #e65c00;
    }
    
    .difficulty-low {
        background-color: #e6f2ff;
        color: #0066cc;
    }
    
    /* AI card container */
    .ai-card-container {
        background-color: #f0f8ff;
        border-left: 4px solid #6c4ed4;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    .ai-card-question {
        font-weight: 500;
        color: #333;
        margin-bottom: 10px;
    }
    
    .ai-card-answer {
        color: #2a6099;
        padding: 10px;
        background-color: #f4f9ff;
        border-radius: 5px;
    }
    
    /* AI badge */
    .ai-badge {
        background-color: #6c4ed4;
        color: white;
        font-size: 0.7rem;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 8px;
    }
    
    /* Selected card indicator */
    .card-selected {
        border: 2px solid #4CAF50;
        background-color: #f0fff0;
    }
    
    /* Card preview */
    .card-preview {
        padding: 15px;
        border-radius: 8px;
        background-color: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 15px;
    }
    
    .card-preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .generation-strategy-badge {
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.75rem;
        font-weight: bold;
    }
    
    .strategy-related {
        background-color: #e6f3ff;
        color: #0066cc;
    }
    
    .strategy-breakdown {
        background-color: #fff2e6;
        color: #cc6600;
    }
    
    .strategy-alternative {
        background-color: #f0e6ff;
        color: #6600cc;
    }
    
    .difficulty-badge {
        padding: 3px 8px;
        border-radius: 10px;
        font-size: 0.7rem;
        margin-left: 8px;
    }
    
    .difficulty-easy {
        background-color: #d4f7d4;
        color: #28a745;
    }
    
    .difficulty-medium {
        background-color: #fff2cc;
        color: #e65c00;
    }
    
    .difficulty-hard {
        background-color: #ffcccc;
        color: #cc0000;
    }
    </style>
    """, unsafe_allow_html=True)

def render_ai_tab():
    """Render the AI tab for analyzing and generating flashcards"""
    st.markdown("""
    <h3 style="margin-bottom: 20px;">AI Flashcard Assistant</h3>
    <p>Analyze difficult cards and generate new flashcards to improve your learning.</p>
    """, unsafe_allow_html=True)
    
    # Main sections
    if not st.session_state.show_select_cards:
        render_analysis_section()
    else:
        render_card_selection_section()
    
    # Display AI-generated cards if any
    if st.session_state.ai_generated_cards:
        render_generated_cards_section()

def render_analysis_section():
    """Render the initial analysis section with the analyze button"""
    # Description
    st.markdown("""
    <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
        <h4 style="color: #333; margin-top: 0;">How it works</h4>
        <p>This tool analyzes your flashcard review history to identify cards you're struggling with. It then uses AI to create new cards that will help you better understand those difficult concepts.</p>
        <ol>
            <li><strong>Analyze</strong> your flashcards to find the ones you've been struggling with</li>
            <li><strong>Select</strong> specific difficult cards you want help with</li>
            <li><strong>Generate</strong> new AI-created flashcards designed to boost your understanding</li>
        </ol>
    </div>
    """, unsafe_allow_html=True)
    
    # Start analysis button
    if st.button("Analyze My Flashcards", key="analyze_btn", use_container_width=True):
        with st.spinner("Analyzing your flashcards..."):
            difficult_cards = analyze_difficult_cards()
            
            if difficult_cards:
                st.session_state.show_select_cards = True
                st.rerun()
            else:
                st.info("No difficult cards found. This could be because you haven't reviewed enough cards yet, or because you're doing well with all your cards!")

def render_card_selection_section():
    """Render the card selection section after analysis"""
    # Header
    if st.session_state.difficult_cards:
        st.markdown(f"""
        <h4>We found {len(st.session_state.difficult_cards)} cards you might be struggling with</h4>
        <p>Select the cards you want help with, then click "Generate AI Flashcards"</p>
        """, unsafe_allow_html=True)
        
        # "Select All" checkbox
        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            select_all = st.checkbox("Select All Cards", key="select_all_cb")
            if select_all:
                for card in st.session_state.difficult_cards:
                    card['selected'] = True
            else:
                # Only deselect all if the user explicitly unchecked the box
                if st.session_state.get("select_all_cb_prev", False) and not select_all:
                    for card in st.session_state.difficult_cards:
                        card['selected'] = False
            
            # Store previous state
            st.session_state.select_all_cb_prev = select_all
        
        # Display difficult cards
        for i, card in enumerate(st.session_state.difficult_cards):
            difficulty_score = card.get('difficulty_score', 5.0)
            
            # Determine difficulty class
            if difficulty_score >= 7.0:
                difficulty_class = "difficulty-high"
                difficulty_text = "High Difficulty"
            elif difficulty_score >= 4.0:
                difficulty_class = "difficulty-medium"
                difficulty_text = "Medium Difficulty"
            else:
                difficulty_class = "difficulty-low"
                difficulty_text = "Low Difficulty"
            
            # Card container with selection state
            card_class = "card-preview card-selected" if card.get('selected', False) else "card-preview"
            
            st.markdown(f"""
            <div class="{card_class}" id="card_{card['id']}">
                <div class="card-preview-header">
                    <span>Card {i+1}</span>
                    <span class="difficulty-indicator {difficulty_class}">{difficulty_text} ({difficulty_score}/10)</span>
                </div>
                <div class="ai-card-question"><strong>Question:</strong> {card['question']}</div>
                <div class="ai-card-answer"><strong>Answer:</strong> {card['answer']}</div>
            </div>
            """, unsafe_allow_html=True)
            
            # Selection checkbox
            st.checkbox(
                "Select this card", 
                key=f"select_card_{card['id']}", 
                value=card.get('selected', False),
                on_change=toggle_card_selection,
                args=(card['id'],)
            )
        
        # Update selected cards count
        selected_count = len([c for c in st.session_state.difficult_cards if c.get('selected', False)])
        
        # AI generation settings
        st.markdown("### Generation Settings")
        
        col1, col2 = st.columns(2)
        with col1:
            st.session_state.ai_settings['generation_strategy'] = st.selectbox(
                "Generation Strategy",
                options=["related", "breakdown", "alternative"],
                index=["related", "breakdown", "alternative"].index(st.session_state.ai_settings.get('generation_strategy', 'related')),
                format_func=lambda x: {
                    "related": "Related Concepts",
                    "breakdown": "Break Down Concepts",
                    "alternative": "Alternative Approaches"
                }.get(x, x),
                help="Choose how AI should generate new cards"
            )
        
        with col2:
            st.session_state.ai_settings['difficulty_level'] = st.selectbox(
                "Difficulty Level",
                options=["easy", "medium", "hard"],
                index=["easy", "medium", "hard"].index(st.session_state.ai_settings.get('difficulty_level', 'medium')),
                format_func=lambda x: x.capitalize(),
                help="Choose the difficulty level for new cards"
            )
        
        st.session_state.ai_settings['num_cards_to_generate'] = st.slider(
            "Number of Cards to Generate",
            min_value=1,
            max_value=10,
            value=st.session_state.ai_settings.get('num_cards_to_generate', 3),
            help="How many new cards should the AI create"
        )
        
        # Save these settings as the defaults
        if st.checkbox("Save as default settings", key="save_as_default", value=False):
            save_ai_settings()
        
        # Generation button
        generate_button = st.button(
            f"Generate AI Flashcards from {selected_count} Selected Cards", 
            key="generate_btn", 
            use_container_width=True,
            disabled=selected_count == 0 or st.session_state.generation_in_progress
        )
        
        if generate_button:
            with st.spinner("Generating AI flashcards... This may take a moment."):
                result = generate_ai_flashcards()
                
                if result['status'] == 'success':
                    st.success(result['message'])
                    st.rerun()
                else:
                    st.error(result['message'])
        
        # Back button
        if st.button("← Back to Analysis", key="back_btn"):
            st.session_state.show_select_cards = False
            st.rerun()
    else:
        st.info("No difficult cards were found. Try reviewing more flashcards first.")
        
        if st.button("← Back", key="back_empty_btn"):
            st.session_state.show_select_cards = False
            st.rerun()

def render_generated_cards_section():
    """Render the section displaying AI-generated cards"""
    st.markdown("""
    <h3 style="margin: 30px 0 20px 0;">AI-Generated Flashcards</h3>
    <p>Review these new flashcards and save them to your collection if they're helpful.</p>
    """, unsafe_allow_html=True)
    
    # Display generation strategy badge
    strategy = st.session_state.ai_settings['generation_strategy']
    difficulty = st.session_state.ai_settings['difficulty_level']
    
    st.markdown(f"""
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <div class="generation-strategy-badge strategy-{strategy}">
            Strategy: {strategy.capitalize()}
        </div>
        <div class="difficulty-badge difficulty-{difficulty}">
            Difficulty: {difficulty.capitalize()}
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Display each generated card
    for i, card in enumerate(st.session_state.ai_generated_cards):
        st.markdown(f"""
        <div class="ai-card-container">
            <h4>Card {i+1} <span class="ai-badge">AI</span></h4>
            <div class="ai-card-question"><strong>Question:</strong> {card['question']}</div>
            <div class="ai-card-answer"><strong>Answer:</strong> {card['answer']}</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Save button
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("Save All to My Flashcards", key="save_ai_cards_btn", use_container_width=True):
            result = save_ai_generated_cards()
            
            if result['status'] == 'success':
                st.success(result['message'])
                time.sleep(1)
                st.rerun()
            else:
                st.error(result['message'])
    
    with col2:
        if st.button("Generate More Cards", key="generate_more_btn", use_container_width=True):
            with st.spinner("Generating more flashcards..."):
                result = generate_ai_flashcards()
                
                if result['status'] == 'success':
                    st.success(result['message'])
                    st.rerun()
                else:
                    st.error(result['message'])

================================================================================
File: frontend/flashcards.py
Size: 45.12 kB
================================================================================

import streamlit as st
import time
import json
from datetime import datetime, timedelta
import os
import random
import uuid
from pathlib import Path
import requests
import base64
from io import BytesIO
from PIL import Image
import urllib.parse
from frontend.middleware import analyze_difficult_flashcards, generate_ai_flashcards
from frontend.flashcard_ai import init_flashcard_ai_state, render_ai_tab, apply_custom_ai_css

# Default flashcard settings
DEFAULT_FLASHCARD_SETTINGS = {
    "new_cards_per_day": 10,
    "review_cards_per_day": 20,
    "ease_factor_default": 2.5,
    "initial_interval": 1, # in days
    "interval_modifier": 1.0,
    "auto_save": True
}

# Initialize session state variables for flashcards
def init_flashcards_state():
    """Initialize flashcards-related session state variables"""
    if "flashcards" not in st.session_state:
        # Load existing cards if available
        cards_file = Path("flashcards.json")
        if cards_file.exists():
            try:
                with open(cards_file, "r") as f:
                    st.session_state.flashcards = json.load(f)
            except Exception as e:
                st.error(f"Failed to load flashcards: {e}")
                st.session_state.flashcards = []
        else:
            st.session_state.flashcards = []
    
    if "flashcard_settings" not in st.session_state:
        # Load settings if available
        settings_file = Path("flashcard_settings.json")
        if settings_file.exists():
            try:
                with open(settings_file, "r") as f:
                    st.session_state.flashcard_settings = json.load(f)
            except Exception as e:
                st.error(f"Failed to load flashcard settings: {e}")
                st.session_state.flashcard_settings = DEFAULT_FLASHCARD_SETTINGS
        else:
            st.session_state.flashcard_settings = DEFAULT_FLASHCARD_SETTINGS
    
    if "current_flashcard" not in st.session_state:
        st.session_state.current_flashcard = None
    
    if "show_answer" not in st.session_state:
        st.session_state.show_answer = False
    
    if "flashcard_stats" not in st.session_state:
        # Load stats if available
        stats_file = Path("flashcard_stats.json")
        if stats_file.exists():
            try:
                with open(stats_file, "r") as f:
                    st.session_state.flashcard_stats = json.load(f)
                    # Check if it's a new day since the last study
                    if st.session_state.flashcard_stats.get("last_study_date"):
                        last_study = datetime.fromisoformat(st.session_state.flashcard_stats["last_study_date"])
                        today = datetime.now()
                        if last_study.date() < today.date():
                            # Reset daily stats for a new day
                            st.session_state.flashcard_stats["studied_today"] = 0
                            st.session_state.flashcard_stats["correct_today"] = 0
            except Exception as e:
                st.error(f"Failed to load flashcard stats: {e}")
                st.session_state.flashcard_stats = {
                    "studied_today": 0,
                    "total_studied": 0,
                    "correct_today": 0,
                    "total_correct": 0,
                    "streak": 0,
                    "last_study_date": None
                }
        else:
            st.session_state.flashcard_stats = {
                "studied_today": 0,
                "total_studied": 0,
                "correct_today": 0,
                "total_correct": 0,
                "streak": 0,
                "last_study_date": None
            }
        
    # Add a flag to reset the form
    if "reset_flashcard_form" not in st.session_state:
        st.session_state.reset_flashcard_form = False
        
    # Add a flag to get the next card
    if "get_next_flashcard" not in st.session_state:
        st.session_state.get_next_flashcard = False
        
    # Initialize AI-related state
    init_flashcard_ai_state()

# Spaced repetition algorithm functions
def calculate_next_review(card, ease):
    """
    Calculate the next review date based on SM-2 algorithm
    
    Parameters:
    - card: The flashcard with review history
    - ease: The ease factor (1-4) representing difficulty
        1: Again - Card was not remembered, start over
        2: Hard - Card was remembered with difficulty
        3: Good - Card was remembered with some effort
        4: Easy - Card was remembered easily
    
    Returns:
    - Updated card with new review date and interval
    """
    # Get default values if not present in card
    interval = card.get('interval', st.session_state.flashcard_settings['initial_interval'])
    ease_factor = card.get('ease_factor', st.session_state.flashcard_settings['ease_factor_default'])
    repetitions = card.get('repetitions', 0)
    
    # Update based on SM-2 algorithm
    if ease == 1:  # Again
        repetitions = 0
        interval = st.session_state.flashcard_settings['initial_interval']
    elif ease == 2:  # Hard
        ease_factor = max(1.3, ease_factor - 0.15)
        if repetitions == 0:
            interval = st.session_state.flashcard_settings['initial_interval']
        else:
            interval = max(1, interval * 1.2 * st.session_state.flashcard_settings['interval_modifier'])
        repetitions += 1
    elif ease == 3:  # Good
        if repetitions == 0:
            interval = 1
        elif repetitions == 1:
            interval = 3
        else:
            interval = interval * ease_factor * st.session_state.flashcard_settings['interval_modifier']
        repetitions += 1
    elif ease == 4:  # Easy
        if repetitions == 0:
            interval = 3
        elif repetitions == 1:
            interval = 7
        else:
            interval = interval * ease_factor * 1.3 * st.session_state.flashcard_settings['interval_modifier']
        ease_factor = min(3.0, ease_factor + 0.15)
        repetitions += 1
    
    # Calculate next review date
    next_review = datetime.now() + timedelta(days=interval)
    
    # Update card
    card['interval'] = interval
    card['ease_factor'] = ease_factor
    card['repetitions'] = repetitions
    card['next_review'] = next_review.isoformat()
    card['last_review'] = datetime.now().isoformat()
    
    return card

def get_due_cards(max_cards=None):
    """Get cards due for review today"""
    now = datetime.now()
    due_cards = []
    
    for card in st.session_state.flashcards:
        # Check if card has never been reviewed or is due
        if 'next_review' not in card or datetime.fromisoformat(card['next_review']) <= now:
            due_cards.append(card)
    
    # Limit to max_cards if specified
    if max_cards is not None and len(due_cards) > max_cards:
        due_cards = due_cards[:max_cards]
    
    return due_cards

def get_new_cards(max_cards=None):
    """Get cards that have never been studied"""
    new_cards = []
    
    for card in st.session_state.flashcards:
        # Check if the card has never been reviewed (no next_review date)
        # AND check if the card was created today
        if 'next_review' not in card:
            # Check if created today
            if 'created_at' in card:
                created_date = datetime.fromisoformat(card['created_at']).date()
                today = datetime.now().date()
                if created_date == today:
                    new_cards.append(card)
    
    # Shuffle new cards for variety
    random.shuffle(new_cards)
    
    # Limit to max_cards if specified
    if max_cards is not None and len(new_cards) > max_cards:
        new_cards = new_cards[:max_cards]
    
    return new_cards

def save_flashcards():
    """Save flashcards to file"""
    try:
        with open("flashcards.json", "w") as f:
            json.dump(st.session_state.flashcards, f, indent=2)
    except Exception as e:
        st.error(f"Failed to save flashcards: {e}")

def save_flashcard_settings():
    """Save flashcard settings to file"""
    try:
        with open("flashcard_settings.json", "w") as f:
            json.dump(st.session_state.flashcard_settings, f, indent=2)
    except Exception as e:
        st.error(f"Failed to save flashcard settings: {e}")

def save_ai_settings():
    """Save AI assistant settings to file"""
    try:
        with open("flashcard_ai_settings.json", "w") as f:
            json.dump(st.session_state.ai_settings, f, indent=2)
    except Exception as e:
        st.error(f"Failed to save AI settings: {e}")

def save_flashcard_stats():
    """Save flashcard stats to file"""
    try:
        with open("flashcard_stats.json", "w") as f:
            json.dump(st.session_state.flashcard_stats, f, indent=2)
    except Exception as e:
        st.error(f"Failed to save flashcard stats: {e}")

def handle_card_action(ease):
    """Handle a response to a flashcard"""
    if st.session_state.current_flashcard:
        # Update card using spaced repetition algorithm
        card_id = st.session_state.current_flashcard['id']
        
        # Find the card in the list
        for i, card in enumerate(st.session_state.flashcards):
            if card['id'] == card_id:
                # Calculate next review date
                updated_card = calculate_next_review(st.session_state.flashcards[i], ease)
                st.session_state.flashcards[i] = updated_card
                
                # Update stats
                st.session_state.flashcard_stats['studied_today'] += 1
                st.session_state.flashcard_stats['total_studied'] += 1
                if ease >= 3:  # Good or Easy
                    st.session_state.flashcard_stats['correct_today'] += 1
                    st.session_state.flashcard_stats['total_correct'] += 1
                    st.session_state.flashcard_stats['streak'] += 1
                else:
                    st.session_state.flashcard_stats['streak'] = 0
                
                st.session_state.flashcard_stats['last_study_date'] = datetime.now().isoformat()
                
                # Auto-save if enabled
                if st.session_state.flashcard_settings['auto_save']:
                    save_flashcards()
                    save_flashcard_stats()
                
                # Reset current card and show_answer
                st.session_state.current_flashcard = None
                st.session_state.show_answer = False
                
                # Set a flag to indicate we need to get a new card
                st.session_state.get_next_flashcard = True
                
                # Don't call rerun here, it will be handled in the main render function
                break

def get_next_card():
    """Get the next card to review"""
    # Check for due cards first
    due_cards = get_due_cards(st.session_state.flashcard_settings['review_cards_per_day'])
    if due_cards:
        return random.choice(due_cards)
    
    # If no due cards, get new cards
    new_cards = get_new_cards(st.session_state.flashcard_settings['new_cards_per_day'])
    if new_cards:
        return new_cards[0]
    
    return None

def toggle_show_answer():
    """Toggle showing the answer"""
    st.session_state.show_answer = not st.session_state.show_answer

def create_new_card():
    """Add a new flashcard"""
    title = st.session_state.new_title
    question = st.session_state.new_question
    answer = st.session_state.new_answer
    image_url = st.session_state.new_image_url
    
    if question.strip() and answer.strip():
        new_card = {
            'id': str(uuid.uuid4()),
            'title': title.strip(),
            'question': question,
            'answer': answer,
            'image_url': image_url.strip(),
            'created_at': datetime.now().isoformat(),
            'tags': [],
            'repetitions': 0,
            'ease_factor': st.session_state.flashcard_settings['ease_factor_default']
        }
        
        st.session_state.flashcards.append(new_card)
        
        # Auto-save if enabled
        if st.session_state.flashcard_settings['auto_save']:
            save_flashcards()
        
        # Instead of clearing directly, set a flag to indicate form should be reset
        st.session_state.reset_flashcard_form = True
        
        # Show success message
        st.success("New flashcard created successfully!")
        time.sleep(1)
        st.rerun()

def apply_custom_flashcards_css():
    """Apply custom CSS for the flashcards interface"""
    st.markdown("""
    <style>
    /* Flashcard container */
    .flashcard-container {
        background-color: white;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        text-align: center;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    
    /* Flashcard question and answer */
    .flashcard-question {
        font-size: 1.5rem;
        font-weight: 500;
        color: #333;
        margin-bottom: 20px;
    }
    
    .flashcard-answer {
        font-size: 1.3rem;
        color: #2a6099;
        padding: 15px;
        background-color: #f4f9ff;
        border-radius: 8px;
        margin-top: 20px;
        border-left: 4px solid #4A76F9;
    }
    
    /* Stats container */
    .stats-container {
        background-color: #f0f4f9;
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
    }
    
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-top: 10px;
    }
    
    .stat-item {
        background-color: white;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    .stat-value {
        font-size: 1.8rem;
        font-weight: bold;
        color: #6c4ed4;
    }
    
    .stat-label {
        font-size: 0.8rem;
        color: #666;
    }
    
    /* Button group styling */
    .button-group {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
    }
    
    /* Response buttons */
    .response-button-again {
        background-color: #ff6b6b !important;
    }
    
    .response-button-hard {
        background-color: #ffa94d !important;
    }
    
    .response-button-good {
        background-color: #69db7c !important;
    }
    
    .response-button-easy {
        background-color: #4dabff !important;
    }
    
    /* Tab styling */
    .stTabs [data-baseweb="tab-list"] {
        gap: 8px;
    }
    
    .stTabs [data-baseweb="tab"] {
        padding: 10px 16px;
        border-radius: 8px;
    }
    
    /* Form styling in Create tab */
    .create-form {
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    </style>
    """, unsafe_allow_html=True)

def download_and_cache_image(url):
    """
    Download an image from a URL and cache it locally.
    Returns the path to the cached image, or None if the download fails.
    """
    # Create a cache directory if it doesn't exist
    cache_dir = Path("image_cache")
    cache_dir.mkdir(exist_ok=True)
    
    # Create a filename based on the URL
    url_hash = str(hash(url))
    file_extension = os.path.splitext(url)[1]
    if not file_extension:
        file_extension = ".png"  # Default extension
    
    cached_file_path = cache_dir / f"{url_hash}{file_extension}"
    
    # If already cached, return the path
    if cached_file_path.exists():
        return str(cached_file_path)
    
    # Try to download the image
    try:
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()  # Raise an exception for bad responses
        
        # Save the image
        with open(cached_file_path, 'wb') as f:
            f.write(response.content)
        
        return str(cached_file_path)
    except Exception as e:
        st.error(f"Failed to download image: {str(e)}")
        return None

def get_image_as_base64(url):
    """
    Convert an image from a URL to a base64 string.
    This works around CORS issues by embedding the image directly.
    """
    try:
        # First try to download the image
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()  # Raise an exception for bad responses
        
        # Convert to base64
        image_data = base64.b64encode(response.content).decode("utf-8")
        # Determine image type
        if url.lower().endswith(".png"):
            mime_type = "image/png"
        elif url.lower().endswith((".jpg", ".jpeg")):
            mime_type = "image/jpeg"
        elif url.lower().endswith(".gif"):
            mime_type = "image/gif"
        elif url.lower().endswith(".svg"):
            mime_type = "image/svg+xml"
        else:
            mime_type = "image/png"  # Default
        
        return f"data:{mime_type};base64,{image_data}"
    except Exception as e:
        st.error(f"Failed to process image: {str(e)}")
        return None

def display_image(url):
    """
    Display an image from a URL using multiple methods for maximum reliability.
    
    This function tries several approaches:
    1. Direct display via st.image
    2. Local caching and display
    3. Base64 encoding to bypass CORS issues
    4. HTML rendering with error handling
    """
    if not url or url.strip() == "":
        return
    
    # Method 1: Try direct display first
    try:
        st.image(url, use_column_width=True)
        return True
    except Exception:
        pass  # If it fails, continue to the next method
    
    # Method 2: Try downloading and caching
    try:
        cached_path = download_and_cache_image(url)
        if cached_path:
            st.image(cached_path, use_column_width=True)
            return True
    except Exception:
        pass  # If it fails, continue to the next method
    
    # Method 3: Try base64 encoding
    try:
        base64_img = get_image_as_base64(url)
        if base64_img:
            st.markdown(f'<img src="{base64_img}" style="width:100%;">', unsafe_allow_html=True)
            return True
    except Exception:
        pass  # If it fails, continue to the next method
    
    # Method 4: Fallback to HTML img tag with error handling
    st.markdown(f"""
    <div>
        <img src="{url}" style="max-width:100%;" onerror="this.onerror=null;this.src='https://placehold.co/600x400?text=Image+Not+Available';"/>
        <p style="color:gray;font-size:0.8em;">Image URL: {url}</p>
    </div>
    """, unsafe_allow_html=True)
    
    return True

def render_study_tab():
    """Render the study tab for reviewing flashcards"""
    # Add a debug button at the top to check session state
    if st.button("🔍 Debug - Show Current Card Data", key="debug_card_btn"):
        st.write("Current flashcard data:")
        st.json(st.session_state.current_flashcard if st.session_state.current_flashcard else {"status": "No card currently loaded"})
        st.write("Session state:")
        st.write({
            "show_answer": st.session_state.show_answer,
            "get_next_flashcard": st.session_state.get_next_flashcard,
            "cards_count": len(st.session_state.flashcards),
            "due_cards_count": len(get_due_cards()),
            "new_cards_count": len(get_new_cards())
        })
    
    # Check if we need to get a new card based on the flag
    if st.session_state.get_next_flashcard:
        st.session_state.current_flashcard = get_next_card()
        st.session_state.get_next_flashcard = False
        st.rerun()
    
    # Get a card if we don't have one
    if not st.session_state.current_flashcard:
        st.session_state.current_flashcard = get_next_card()
    
    # Display card or "all caught up" message
    if st.session_state.current_flashcard:
        # Use a completely different approach with custom HTML and consistent styling
        
        card = st.session_state.current_flashcard
        title = card.get("title", "")
        question = card.get("question", "Question not available")
        answer = card.get("answer", "Answer not available")
        image_url = card.get("image_url", "")
        
        # Create a container with custom styling
        st.markdown("""
        <style>
        .flashcard-box {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            padding: 2rem;
            margin: 1.5rem 0;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #6c4ed4;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        
        .question-text {
            font-size: 1.5rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .answer-box {
            background-color: #f4f9ff;
            border-left: 5px solid #4A76F9;
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            font-size: 1.2rem;
            color: #2a6099;
        }
        
        .rating-text {
            margin: 1rem 0;
            font-size: 1.1rem;
            color: #666;
            text-align: center;
        }
        
        .card-image {
            max-width: 100%;
            margin-top: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        </style>
        """, unsafe_allow_html=True)
        
        col_left, col_main, col_right = st.columns([1, 10, 1])
        
        with col_main:
            # Render the flashcard box
            st.markdown(f"""
            <div class="flashcard-box">
                {f'<div class="card-title">{title}</div>' if title else ''}
                <div class="question-text">{question}</div>
            """, unsafe_allow_html=True)
            
            # Show answer section (using standard Streamlit components for the button)
            if not st.session_state.show_answer:
                # Center the Show Answer button
                btn_col1, btn_col2, btn_col3 = st.columns([1, 2, 1])
                with btn_col2:
                    st.button("Show Answer", key="show_answer_btn", 
                             on_click=toggle_show_answer, use_container_width=True)
            else:
                # Show answer and rating buttons
                st.markdown(f"""
                <div class="answer-box">{answer}</div>
                """, unsafe_allow_html=True)
                
                # Display image if available
                if image_url:
                    display_image(image_url)
                
                st.markdown(f"""
                <p class="rating-text">How well did you remember this?</p>
                """, unsafe_allow_html=True)
                
                # Use standard Streamlit components for rating buttons
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.button("Again", key="again_btn", 
                              on_click=handle_card_action, kwargs={"ease": 1},
                              use_container_width=True, 
                              help="I didn't remember this time")
                
                with col2:
                    st.button("Hard", key="hard_btn", 
                              on_click=handle_card_action, kwargs={"ease": 2},
                              use_container_width=True, 
                              help="I remembered with difficulty")
                
                with col3:
                    st.button("Good", key="good_btn", 
                              on_click=handle_card_action, kwargs={"ease": 3},
                              use_container_width=True, 
                              help="I remembered with some effort")
                
                with col4:
                    st.button("Easy", key="easy_btn", 
                              on_click=handle_card_action, kwargs={"ease": 4},
                              use_container_width=True, 
                              help="I remembered easily")
            
            st.markdown("</div>", unsafe_allow_html=True)
            
        # Show card details
        with st.expander("Card Details"):
            if title:
                st.write(f"Title: {title}")
            st.write(f"Card ID: {card.get('id', 'N/A')}")
            st.write(f"Created: {datetime.fromisoformat(card.get('created_at', datetime.now().isoformat())).strftime('%Y-%m-%d')}")
            
            # Improve repetitions display
            rep_count = card.get('repetitions', 0)
            if 'last_review' in card:  # Card has been reviewed at least once
                st.write(f"Reviews: {rep_count}")
            else:
                st.write("Reviews: Never reviewed")
                
            if 'last_review' in card:
                st.write(f"Last review: {datetime.fromisoformat(card['last_review']).strftime('%Y-%m-%d')}")
            
            if 'next_review' in card:
                next_review = datetime.fromisoformat(card['next_review'])
                now = datetime.now()
                time_delta = next_review - now
                
                # Calculate days, hours, minutes
                days = time_delta.days
                hours = time_delta.seconds // 3600
                minutes = (time_delta.seconds % 3600) // 60
                
                # Format the time until next review
                time_str = ""
                if days > 0:
                    time_str += f"{days} day{'s' if days != 1 else ''}, "
                if hours > 0 or days > 0:  # Show hours if days are shown
                    time_str += f"{hours} hour{'s' if hours != 1 else ''}, "
                time_str += f"{minutes} minute{'s' if minutes != 1 else ''}"
                
                st.write(f"Next review: {next_review.strftime('%Y-%m-%d')} ({time_str})")
                
    else:
        # No cards due - this is using standard Streamlit components for reliability
        st.info("🎉 All caught up! You've reviewed all your due cards for today. Come back tomorrow or create new cards.")
        
        # Add a button to reset and try again
        if st.button("Find Cards to Review Anyway", key="force_review", help="This will find cards to review even if they're not due yet"):
            # Reset the current card and force a refresh
            st.session_state.current_flashcard = None
            st.session_state.get_next_flashcard = True
            st.rerun()

def render_create_tab():
    """Render the create tab for adding new flashcards"""
    st.markdown("""
    <h3 style="margin-bottom: 20px;">Create New Flashcards</h3>
    """, unsafe_allow_html=True)
    
    # Check if we need to reset the form
    if st.session_state.reset_flashcard_form:
        # Reset the flag first
        st.session_state.reset_flashcard_form = False
        # The form will be cleared on the next rerun
        st.rerun()
    
    with st.form(key="new_card_form", clear_on_submit=False):
        # Initialize session state for form inputs if needed
        if "new_title" not in st.session_state:
            st.session_state.new_title = ""
        if "new_question" not in st.session_state:
            st.session_state.new_question = ""
        if "new_answer" not in st.session_state:
            st.session_state.new_answer = ""
        if "new_image_url" not in st.session_state:
            st.session_state.new_image_url = ""
        
        title = st.text_input("Title", key="new_title", placeholder="Enter a title for the flashcard...")
        question = st.text_area("Question", key="new_question", height=100, 
                     placeholder="Enter your question here...")
        answer = st.text_area("Answer", key="new_answer", height=150,
                     placeholder="Enter the answer here...")
        image_url = st.text_input("Image URL", key="new_image_url", placeholder="Optional: Enter an image URL...")
        
        # Preview image if URL is provided
        if image_url:
            st.caption("Image Preview:")
            display_image(image_url)
        
        submitted = st.form_submit_button("Create Flashcard", use_container_width=True)
        if submitted:
            create_new_card()

def render_manage_tab():
    """Render the manage tab for viewing and editing flashcards"""
    st.markdown("""
    <h3 style="margin-bottom: 20px;">Manage Flashcards</h3>
    """, unsafe_allow_html=True)
    
    # Filter options
    col1, col2 = st.columns(2)
    with col1:
        filter_option = st.selectbox(
            "Filter cards by",
            ["All Cards", "Due Today", "New Cards", "Reviewed Cards"]
        )
    
    with col2:
        sort_option = st.selectbox(
            "Sort by",
            ["Date Created (Newest)", "Date Created (Oldest)", "Next Review Date"]
        )
    
    # Get filtered cards
    filtered_cards = st.session_state.flashcards.copy()
    
    if filter_option == "Due Today":
        now = datetime.now()
        filtered_cards = [card for card in filtered_cards if 
                         'next_review' not in card or 
                         datetime.fromisoformat(card['next_review']) <= now]
    elif filter_option == "New Cards":
        filtered_cards = [card for card in filtered_cards if 'next_review' not in card]
    elif filter_option == "Reviewed Cards":
        filtered_cards = [card for card in filtered_cards if 'next_review' in card]
    
    # Sort cards
    if sort_option == "Date Created (Newest)":
        filtered_cards.sort(key=lambda x: x.get('created_at', ''), reverse=True)
    elif sort_option == "Date Created (Oldest)":
        filtered_cards.sort(key=lambda x: x.get('created_at', ''))
    elif sort_option == "Next Review Date":
        # Sort by next_review, putting cards without next_review at the top
        def get_next_review(card):
            if 'next_review' not in card:
                return datetime.min
            return datetime.fromisoformat(card['next_review'])
        
        filtered_cards.sort(key=get_next_review)
    
    # Display cards
    if filtered_cards:
        st.write(f"Showing {len(filtered_cards)} cards")
        for i, card in enumerate(filtered_cards):
            # Use title in the expander if available, otherwise use the question
            display_title = card.get('title', '')
            display_text = display_title if display_title else card['question'][:50] + ('...' if len(card['question']) > 50 else '')
            
            with st.expander(f"Card {i+1}: {display_text}"):
                # Card details
                if 'title' in card and card['title'].strip():
                    st.markdown(f"**Title:**\n{card['title']}")
                st.markdown(f"**Question:**\n{card['question']}")
                st.markdown(f"**Answer:**\n{card['answer']}")
                
                # Display image if available
                if card.get('image_url'):
                    st.markdown("**Image:**")
                    display_image(card['image_url'])
                
                # Card metadata
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown(f"**Created:** {datetime.fromisoformat(card['created_at']).strftime('%Y-%m-%d')}")
                    if 'last_review' in card:
                        st.markdown(f"**Last Review:** {datetime.fromisoformat(card['last_review']).strftime('%Y-%m-%d')}")
                
                with col2:
                    if 'next_review' in card:
                        next_review = datetime.fromisoformat(card['next_review'])
                        now = datetime.now()
                        time_delta = next_review - now
                        
                        # Calculate days, hours, minutes
                        days = time_delta.days
                        hours = time_delta.seconds // 3600
                        minutes = (time_delta.seconds % 3600) // 60
                        
                        # Format the time until next review
                        time_str = ""
                        if days > 0:
                            time_str += f"{days} day{'s' if days != 1 else ''}, "
                        if hours > 0 or days > 0:  # Show hours if days are shown
                            time_str += f"{hours} hour{'s' if hours != 1 else ''}, "
                        time_str += f"{minutes} minute{'s' if minutes != 1 else ''}"
                        
                        st.markdown(f"**Next Review:** {next_review.strftime('%Y-%m-%d')} ({time_str})")
                    
                    rep_count = card.get('repetitions', 0)
                    if 'last_review' in card:  # Card has been reviewed at least once
                        st.markdown(f"**Reviews:** {rep_count}")
                    else:
                        st.markdown("**Reviews:** Never reviewed")
                
                # Edit and delete buttons
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("Edit", key=f"edit_{card['id']}"):
                        st.session_state.editing_card = card
                        st.session_state.edit_title = card.get('title', '')
                        st.session_state.edit_question = card['question']
                        st.session_state.edit_answer = card['answer']
                        st.session_state.edit_image_url = card.get('image_url', '')
                
                with col2:
                    if st.button("Delete", key=f"delete_{card['id']}"):
                        # Remove card from list
                        st.session_state.flashcards = [c for c in st.session_state.flashcards if c['id'] != card['id']]
                        
                        # Save changes
                        if st.session_state.flashcard_settings['auto_save']:
                            save_flashcards()
                        
                        st.success("Card deleted successfully!")
                        time.sleep(1)
                        st.rerun()
    else:
        st.info("No cards match the selected filter criteria.")
    
    # Save button for all changes
    if st.button("Save All Changes", use_container_width=True):
        save_flashcards()
        st.success("All changes saved successfully!")

def render_stats_tab():
    """Render the stats tab for viewing performance statistics"""
    st.markdown("""
    <h3 style="margin-bottom: 20px;">Flashcard Statistics</h3>
    """, unsafe_allow_html=True)
    
    # Summary stats
    st.markdown('<div class="stats-container">', unsafe_allow_html=True)
    st.markdown('<h4 style="margin-bottom: 10px;">Summary</h4>', unsafe_allow_html=True)
    
    st.markdown('<div class="stats-grid">', unsafe_allow_html=True)
    
    # Total cards
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{len(st.session_state.flashcards)}</div>
        <div class="stat-label">Total Cards</div>
    </div>
    """, unsafe_allow_html=True)
    
    # Cards due today
    due_cards = get_due_cards()
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{len(due_cards)}</div>
        <div class="stat-label">Due Today</div>
    </div>
    """, unsafe_allow_html=True)
    
    # New cards
    new_cards = get_new_cards()
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{len(new_cards)}</div>
        <div class="stat-label">New Cards</div>
    </div>
    """, unsafe_allow_html=True)
    
    # Current streak - Moved to Summary section
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{st.session_state.flashcard_stats['streak']}</div>
        <div class="stat-label">Current Streak</div>
    </div>
    """, unsafe_allow_html=True)
    
    # Overall success rate
    overall_success_rate = 0
    if st.session_state.flashcard_stats['total_studied'] > 0:
        overall_success_rate = round(st.session_state.flashcard_stats['total_correct'] / st.session_state.flashcard_stats['total_studied'] * 100)
    
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{overall_success_rate}%</div>
        <div class="stat-label">Overall Success</div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Daily progress
    st.markdown('<h4 style="margin: 20px 0 10px 0;">Today\'s Progress</h4>', unsafe_allow_html=True)
    
    st.markdown('<div class="stats-grid">', unsafe_allow_html=True)
    
    # Cards studied today
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{st.session_state.flashcard_stats['studied_today']}</div>
        <div class="stat-label">Cards Studied</div>
    </div>
    """, unsafe_allow_html=True)
    
    # Correct today
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{st.session_state.flashcard_stats['correct_today']}</div>
        <div class="stat-label">Correct Answers</div>
    </div>
    """, unsafe_allow_html=True)
    
    # Today's success rate
    today_success_rate = 0
    if st.session_state.flashcard_stats['studied_today'] > 0:
        today_success_rate = round(st.session_state.flashcard_stats['correct_today'] / st.session_state.flashcard_stats['studied_today'] * 100)
    
    st.markdown(f"""
    <div class="stat-item">
        <div class="stat-value">{today_success_rate}%</div>
        <div class="stat-label">Today's Success</div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Graph of review schedule (to be implemented)
    # Retention rate (to be implemented)

def render_settings_tab():
    """Render the settings tab for flashcard settings"""
    st.markdown("""
    <h3 style="margin-bottom: 20px;">Flashcard Settings</h3>
    """, unsafe_allow_html=True)
    
    # Daily limits
    st.subheader("Daily Limits")
    col1, col2 = st.columns(2)
    
    with col1:
        st.session_state.flashcard_settings['new_cards_per_day'] = st.slider(
            "New cards per day",
            min_value=1,
            max_value=50,
            value=st.session_state.flashcard_settings['new_cards_per_day'],
            step=1,
            help="Maximum number of new cards to show per day"
        )
    
    with col2:
        st.session_state.flashcard_settings['review_cards_per_day'] = st.slider(
            "Review cards per day",
            min_value=1,
            max_value=100,
            value=st.session_state.flashcard_settings['review_cards_per_day'],
            step=5,
            help="Maximum number of review cards to show per day"
        )
    
    # Advanced settings
    st.subheader("Advanced Settings")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.session_state.flashcard_settings['initial_interval'] = st.slider(
            "Initial interval (days)",
            min_value=1,
            max_value=10,
            value=st.session_state.flashcard_settings['initial_interval'],
            step=1,
            help="Number of days before the first review"
        )
    
    with col2:
        st.session_state.flashcard_settings['interval_modifier'] = st.slider(
            "Interval modifier",
            min_value=0.5,
            max_value=2.0,
            value=st.session_state.flashcard_settings['interval_modifier'],
            step=0.1,
            help="Multiplier for all review intervals"
        )
    
    # Auto-save setting
    st.session_state.flashcard_settings['auto_save'] = st.toggle(
        "Auto-save changes",
        value=st.session_state.flashcard_settings['auto_save'],
        help="Automatically save changes when creating or reviewing cards"
    )
    
    # AI Assistant Settings
    st.subheader("AI Assistant Settings")
    
    # Default values if not present
    if 'ai_settings' not in st.session_state:
        st.session_state.ai_settings = {
            "num_cards_to_generate": 3,
            "generation_strategy": "related",
            "difficulty_level": "medium"
        }
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.session_state.ai_settings['num_cards_to_generate'] = st.slider(
            "Default cards to generate",
            min_value=1,
            max_value=10,
            value=st.session_state.ai_settings.get('num_cards_to_generate', 3),
            step=1,
            help="Default number of cards the AI should generate"
        )
    
    with col2:
        st.session_state.ai_settings['difficulty_level'] = st.selectbox(
            "Default difficulty level",
            options=["easy", "medium", "hard"],
            index=["easy", "medium", "hard"].index(st.session_state.ai_settings.get('difficulty_level', 'medium')),
            format_func=lambda x: x.capitalize(),
            help="Default difficulty level for AI-generated cards"
        )
    
    st.session_state.ai_settings['generation_strategy'] = st.selectbox(
        "Default generation strategy",
        options=["related", "breakdown", "alternative"],
        index=["related", "breakdown", "alternative"].index(st.session_state.ai_settings.get('generation_strategy', 'related')),
        format_func=lambda x: {
            "related": "Related Concepts",
            "breakdown": "Break Down Concepts",
            "alternative": "Alternative Approaches"
        }.get(x, x),
        help="Default strategy for generating new flashcards"
    )
    
    # Save button
    if st.button("Save Settings", use_container_width=True):
        save_flashcard_settings()
        # Save AI settings as well
        save_ai_settings()
        st.success("Settings saved successfully!")
    
    # Reset button
    if st.button("Reset to Defaults", use_container_width=True):
        st.session_state.flashcard_settings = DEFAULT_FLASHCARD_SETTINGS
        # Reset AI settings
        st.session_state.ai_settings = {
            "num_cards_to_generate": 3,
            "generation_strategy": "related", 
            "difficulty_level": "medium"
        }
        save_flashcard_settings()
        save_ai_settings()
        st.success("Settings reset to defaults!")
        st.rerun()

def render_flashcards_interface():
    """Main function to render the flashcards interface"""
    # Apply custom CSS
    apply_custom_flashcards_css()
    
    # Header
    st.markdown("""
    <div style="text-align: center; padding: 20px 0; animation: fadeIn 1s ease-in;">
        <h1 style="color: #6c4ed4; margin-bottom: 5px;">📚 Flashcards</h1>
        <p style="color: #666; font-size: 1rem;">Boost your learning with spaced repetition</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Navigation to chat page
    col1, col2 = st.columns([5, 1])
    with col2:
        st.button("💬 Chat", key="goto_chat", on_click=switch_to_chat)
    
    # Create tabs for different sections
    tab_labels = ["Study", "Create", "Manage", "Stats", "AI Assistant", "Settings"]
    tabs = st.tabs(tab_labels)
    
    # Study Tab
    with tabs[0]:
        render_study_tab()
    
    # Create Tab
    with tabs[1]:
        render_create_tab()
    
    # Manage Tab
    with tabs[2]:
        render_manage_tab()
    
    # Stats Tab
    with tabs[3]:
        render_stats_tab()
    
    # AI Assistant Tab
    with tabs[4]:
        apply_custom_ai_css()
        render_ai_tab()
    
    # Settings Tab
    with tabs[5]:
        render_settings_tab()
    
    # Footer
    st.markdown("""
    <div style="text-align: center; color: #888; padding-top: 20px; border-top: 1px solid #eee;">
        <p>Built with ❤️ using Streamlit</p>
    </div>
    """, unsafe_allow_html=True)

def switch_to_flashcards():
    """Switch to the flashcards page"""
    st.session_state.page = "flashcards"

def switch_to_chat():
    """Switch to the chat page"""
    st.session_state.page = "chat"

================================================================================
File: frontend/main.py
Size: 20.86 kB
================================================================================

import streamlit as st
from frontend.middleware import call_backend_test, send_message, save_chat_history, submit_feedback
import time
from datetime import datetime
import random
import uuid
from frontend.settings import init_settings_state, render_settings_tab
from frontend.flashcards import init_flashcards_state, render_flashcards_interface
from frontend.multiplayer import init_multiplayer_state, render_multiplayer_interface

# Configure page at module level for importing modules
st.set_page_config(
    page_title="Modern Chatbot",
    page_icon="💬",
    layout="centered"
)

def initialize_session_state():
    """Initialize session state variables if they don't exist"""
    # Initialize settings-related state first
    init_settings_state()
    
    # Initialize flashcards-related state
    init_flashcards_state()
    
    # Initialize multiplayer-related state
    init_multiplayer_state()
    
    if "messages" not in st.session_state:
        st.session_state.messages = [
            {
                "role": "assistant", 
                "content": "Hello! How can I help you today?", 
                "timestamp": datetime.now().strftime("%H:%M"),
                "id": str(uuid.uuid4())
            }
        ]
    
    if "user_input" not in st.session_state:
        st.session_state.user_input = ""
        
    # Add a flag to track if we need to process a new message
    if "process_new_message" not in st.session_state:
        st.session_state.process_new_message = False
        
    # Add a flag for feedback mode
    if "show_feedback" not in st.session_state:
        st.session_state.show_feedback = False
        
    # Track current message for feedback
    if "current_feedback_msg_id" not in st.session_state:
        st.session_state.current_feedback_msg_id = None
    
    # Set default page
    if "page" not in st.session_state:
        st.session_state.page = "chat"

def submit_message():
    """Callback function when a message is submitted"""
    if st.session_state.current_input.strip():  # Check if input is not just whitespace
        # Get the message content
        user_message = st.session_state.current_input
        
        # Update tracking variables
        st.session_state.user_input = user_message
        st.session_state.process_new_message = True
        
        # Add user message to chat
        timestamp = datetime.now().strftime("%H:%M")
        st.session_state.messages.append(
            {
                "role": "user", 
                "content": user_message, 
                "timestamp": timestamp,
                "id": str(uuid.uuid4())
            }
        )

def switch_to_settings():
    """Switch to the settings page"""
    st.session_state.page = "settings"

def switch_to_chat():
    """Switch to the chat page"""
    st.session_state.page = "chat"

def switch_to_flashcards():
    """Switch to the flashcards page"""
    st.session_state.page = "flashcards"
    
def switch_to_multiplayer():
    """Switch to the multiplayer page"""
    st.session_state.page = "multiplayer"

def apply_custom_css():
    """Apply custom CSS for a beautiful chat interface"""
    st.markdown("""
    <style>
    /* Main container styling */
    .main {
        background-color: #f9f9fb;
    }
    
    /* Header styling */
    .stHeader {
        background-color: #ffffff;
        padding: 1rem;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    
    /* Chat container */
    .chat-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        border-radius: 12px;
    }
    
    /* Message bubbles */
    .assistant-bubble {
        background-color: #f0f4f9;
        border-radius: 18px 18px 18px 0;
        padding: 12px 18px;
        margin-bottom: 10px;
        display: inline-block;
        max-width: 80%;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    
    .user-bubble {
        background-color: #4A76F9;
        color: white;
        border-radius: 18px 18px 0 18px;
        padding: 12px 18px;
        margin-bottom: 10px;
        display: inline-block;
        max-width: 80%;
        float: right;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    
    /* Timestamp styling */
    .timestamp {
        font-size: 0.7rem;
        color: #888;
        margin-top: 4px;
        display: block;
    }
    
    /* Typing animation */
    .typing-animation {
        display: inline-flex;
        align-items: center;
        height: 30px;
    }
    
    .typing-dot {
        width: 8px;
        height: 8px;
        margin: 0 2px;
        background-color: #888;
        border-radius: 50%;
        opacity: 0.6;
        animation: pulse 1.5s infinite ease-in-out;
    }
    
    .typing-dot:nth-child(1) {
        animation-delay: 0s;
    }
    
    .typing-dot:nth-child(2) {
        animation-delay: 0.3s;
    }
    
    .typing-dot:nth-child(3) {
        animation-delay: 0.6s;
    }
    
    @keyframes pulse {
        0%, 100% {
            opacity: 0.3;
            transform: scale(0.8);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.2);
        }
    }
    
    /* Input box styling */
    .stTextInput > div > div > input {
        border-radius: 20px !important;
        padding-left: 20px !important;
    }
    
    /* Send button styling */
    .stButton > button {
        border-radius: 8px !important;  /* Changed from 50% to 8px for rectangular buttons */
        padding: 0.5rem 1rem !important; /* Added padding for better text display */
        height: auto !important; /* Allow height to adjust to content */
        width: auto !important; /* Allow width to adjust to content */
        min-width: 44px !important; /* Minimum width to fit content */
        min-height: 44px !important; /* Minimum height for touch targets */
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        background-color: #4A76F9 !important;
        color: white !important;
        font-size: 1rem !important; /* Larger font size for better readability */
    }
    
    /* Settings button specific styling */
    button[data-testid="baseButton-secondary"]:has(div:contains("⚙️")) {
        padding: 0.5rem 1rem !important;
        width: auto !important;
        border-radius: 8px !important;
        background-color: #6c4ed4 !important;
        color: white !important;
    }
    
    /* Back button styling */
    button[data-testid="baseButton-secondary"]:has(div:contains("Back")) {
        padding: 0.5rem 1.2rem !important;
        width: auto !important;
        border-radius: 8px !important;
        background-color: #f0f0f0 !important;
        color: #333 !important;
    }
    
    /* Primary button styling (Save Settings) */
    button[data-testid="baseButton-primary"] {
        padding: 0.7rem 1.5rem !important;
        width: auto !important;
        border-radius: 8px !important;
        font-weight: 600 !important;
    }
    
    /* Send icon styling */
    .send-icon {
        font-size: 16px;
    }
    
    /* Spinner animation for loading state */
    @keyframes spinner {
        to {transform: rotate(360deg);}
    }
    
    .spinner:before {
        content: '';
        box-sizing: border-box;
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin-top: -10px;
        margin-left: -10px;
        border-radius: 50%;
        border: 2px solid #ccc;
        border-top-color: #333;
        animation: spinner .6s linear infinite;
    }
    
    /* Sidebar navigation */
    .sidebar-nav {
        background-color: #ffffff;
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        margin-bottom: 20px;
    }
    
    .sidebar-nav h3 {
        color: #6c4ed4;
        font-size: 1.2rem;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #f0f0f0;
    }
    
    .sidebar-nav-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        margin-bottom: 5px;
        border-radius: 8px;
        cursor: pointer;
        text-decoration: none;
        color: #333;
        transition: background-color 0.2s;
    }
    
    .sidebar-nav-item:hover {
        background-color: #f8f9fa;
    }
    
    .sidebar-nav-item.active {
        background-color: #6c4ed4;
        color: white;
    }
    
    .sidebar-nav-icon {
        margin-right: 10px;
        font-size: 1.2rem;
        display: inline-block;
        width: 24px;
        text-align: center;
    }
    
    /* Nav bar styling */
    .nav-container {
        display: flex;
        justify-content: flex-end;
        padding: 10px 20px;
    }
    
    /* Custom scrollbar */
    ::-webkit-scrollbar {
        width: 6px;
    }
    
    ::-webkit-scrollbar-track {
        background: #f1f1f1;
    }
    
    ::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
        background: #a8a8a8;
    }
    </style>
    """, unsafe_allow_html=True)

def render_chat_message(message):
    """Render a chat message with styling based on role"""
    role = message["role"]
    content = message["content"]
    timestamp = message.get("timestamp", "")
    metrics = message.get("metrics", {})
    
    # Check if content appears to be a JSON string containing the response data
    if role == "assistant" and isinstance(content, str) and content.startswith("{") and "response" in content and "metrics" in content:
        try:
            import json
            # Try to parse the content as JSON
            parsed_content = json.loads(content.replace("'", '"'))
            if isinstance(parsed_content, dict) and "response" in parsed_content and "metrics" in parsed_content:
                # Extract the actual response content and metrics
                content = parsed_content["response"]
                metrics = parsed_content["metrics"]
        except:
            # If parsing fails, leave content as is
            pass
    
    if role == "assistant":
        st.markdown(f"""
        <div style="display: flex; margin-bottom: 15px;">
            <div style="background-color: #6c4ed4; color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; margin-right: 10px; flex-shrink: 0">
                <span style="font-size: 16px;">🤖</span>
            </div>
            <div>
                <div class="assistant-bubble">{content}</div>
                <span class="timestamp">{timestamp}</span>
                <div style="font-size: 0.8rem; color: #888; margin-top: 5px;">
                    Tokens: {metrics.get("total_tokens", 0)} | Time: {metrics.get("response_time", 0)}s
                </div>
            </div>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown(f"""
        <div style="display: flex; flex-direction: row-reverse; margin-bottom: 15px;">
            <div style="background-color: #f0f0f0; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; margin-left: 10px; flex-shrink: 0">
                <span style="font-size: 16px;">👤</span>
            </div>
            <div style="text-align: right;">
                <div class="user-bubble">{content}</div>
                <span class="timestamp">{timestamp}</span>
            </div>
        </div>
        """, unsafe_allow_html=True)

def show_typing_animation():
    """Show a typing animation while the assistant is "thinking"""
    typing_container = st.empty()
    typing_container.markdown("""
    <div style="display: flex; margin-bottom: 15px;">
        <div style="background-color: #6c4ed4; color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; margin-right: 10px; flex-shrink: 0">
            <span style="font-size: 16px;">🤖</span>
        </div>
        <div class="assistant-bubble typing-animation">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
        </div>
    </div>
    """, unsafe_allow_html=True)
    return typing_container

def create_chat_input():
    """Create a styled chat input area with a send button"""
    col1, col2 = st.columns([6, 1])
    
    with col1:
        # Use the on_change parameter to call our function when input changes
        user_input = st.text_input(
            "Type a message...",
            key="current_input",
            label_visibility="collapsed",
            placeholder="Type your message here...",
            on_change=submit_message
        )
    
    with col2:
        send_button = st.button(
            "Send ➤", 
            key="send",
            help="Send message",
            on_click=submit_message
        )
    
    return user_input, send_button

def render_sidebar():
    """Render the sidebar navigation"""
    with st.sidebar:
        st.markdown('<div class="sidebar-nav">', unsafe_allow_html=True)
        st.markdown('<h3>Navigation</h3>', unsafe_allow_html=True)
        
        # Chat navigation item
        chat_class = "active" if st.session_state.page == "chat" else ""
        if st.button("💬 Chat", key="chat-nav-btn", help="Go to Chat", use_container_width=True, 
                   type="secondary" if st.session_state.page != "chat" else "primary"):
            switch_to_chat()
        
        # Flashcards navigation item
        flashcards_class = "active" if st.session_state.page == "flashcards" else ""
        if st.button("📚 Flashcards", key="flashcards-nav-btn", help="Go to Flashcards", use_container_width=True,
                   type="secondary" if st.session_state.page != "flashcards" else "primary"):
            switch_to_flashcards()
        
        # Multiplayer navigation item
        multiplayer_class = "active" if st.session_state.page == "multiplayer" else ""
        if st.button("🎮 Multiplayer", key="multiplayer-nav-btn", help="Go to Multiplayer", use_container_width=True,
                   type="secondary" if st.session_state.page != "multiplayer" else "primary"):
            switch_to_multiplayer()
        
        # Settings navigation item
        settings_class = "active" if st.session_state.page == "settings" else ""
        if st.button("⚙️ Settings", key="settings-nav-btn", help="Go to Settings", use_container_width=True,
                   type="secondary" if st.session_state.page != "settings" else "primary"):
            switch_to_settings()
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        # App info section
        st.markdown("""
        <div style="padding: 15px 10px; background-color: #f8f9fa; border-radius: 8px; margin-top: 20px;">
            <h4 style="color: #6c4ed4; font-size: 1.1rem; margin-bottom: 10px;">About</h4>
            <p style="color: #666; font-size: 0.9rem;">
                Modern Chatbot with RAG capabilities and flashcard learning system with spaced repetition.
            </p>
        </div>
        """, unsafe_allow_html=True)

def render_chat_interface():
    """Render the chat interface"""
    # Header with subtle animation
    st.markdown("""
    <div style="text-align: center; padding: 20px 0; animation: fadeIn 1s ease-in;">
        <h1 style="color: #6c4ed4; margin-bottom: 5px;">✨ Modern Chatbot ✨</h1>
        <p style="color: #666; font-size: 1rem;">Ask me anything and I'll do my best to help!</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Check backend connection
    backend_status = call_backend_test()
    
    # Show model info if enabled
    if st.session_state.settings["other"]["show_model_info"]:
        model_info = f"Model: {st.session_state.settings['model']['provider']}/{st.session_state.settings['model']['model_name']}"
        st.markdown(f"<p style='text-align: center; color: #888; font-size: 0.8rem;'>{model_info}</p>", unsafe_allow_html=True)
    
    # Chat container
    chat_container = st.container()
    
    # Display chat messages
    with chat_container:
        st.markdown('<div class="chat-container">', unsafe_allow_html=True)
        for message in st.session_state.messages:
            render_chat_message(message)
        st.markdown('</div>', unsafe_allow_html=True)
    
    # Chat input
    st.markdown("<div style='padding: 20px 0;'></div>", unsafe_allow_html=True)
    user_input, send_button = create_chat_input()
    
    # Process user message if the flag is set
    if st.session_state.process_new_message:
        # Reset the flag
        st.session_state.process_new_message = False
        
        # Get the last user message
        user_message = st.session_state.messages[-1]["content"]
        
        # Show typing animation
        typing_animation = show_typing_animation()
        
        # Simulate thinking/processing time
        time.sleep(random.uniform(0.5, 1.5))
        
        try:
            # Call backend API to get response
            if backend_status:
                # Get response from backend
                api_response = send_message(user_message)
                
                # Debug the response structure
                print(f"API Response: {api_response}")
                
                # Extract message text and metrics data
                if isinstance(api_response, dict):
                    # Get the actual message text, not the entire response object
                    assistant_message = api_response.get("response", "Sorry, I couldn't process your request at the moment.")
                    
                    # Extract metrics separately
                    metrics = api_response.get("metrics", {
                        "input_tokens": 0,
                        "output_tokens": 0,
                        "total_tokens": 0,
                        "response_time": 0
                    })
                else:
                    # Fallback if response is not a dictionary
                    assistant_message = str(api_response)
                    metrics = {
                        "input_tokens": 0,
                        "output_tokens": 0,
                        "total_tokens": 0,
                        "response_time": 0
                    }
            else:
                assistant_message = "Sorry, I'm having trouble connecting to my brain right now. Please try again later."
                metrics = {
                    "input_tokens": 0,
                    "output_tokens": 0,
                    "total_tokens": 0,
                    "response_time": 0
                }
                st.error("Backend is not responding", icon="🚫")
                
        except Exception as e:
            assistant_message = f"Oops! Something went wrong: {str(e)}"
            metrics = {
                "input_tokens": 0,
                "output_tokens": 0,
                "total_tokens": 0,
                "response_time": 0
            }
            st.error(f"Error: {str(e)}", icon="⚠️")
        
        # Remove typing animation
        typing_animation.empty()
        
        # Add assistant response to chat
        timestamp = datetime.now().strftime("%H:%M")
        st.session_state.messages.append({
            "role": "assistant", 
            "content": assistant_message,  # Store only the message text, not the entire response
            "timestamp": timestamp,
            "id": str(uuid.uuid4()),
            "metrics": metrics  # Store metrics separately
        })
        
        # Save chat history
        save_chat_history(st.session_state.messages)
        
        # Rerun to update UI with assistant message
        st.rerun()
    
    # Add some space at the bottom
    st.markdown("<div style='padding: 20px 0;'></div>", unsafe_allow_html=True)
    
    # Footer
    st.markdown("""
    <div style="text-align: center; color: #888; padding-top: 20px; border-top: 1px solid #eee;">
        <p>Built with ❤️ using Streamlit</p>
    </div>
    """, unsafe_allow_html=True)

def main():
    """Main entry point for the Streamlit app"""
    # Initialize session state
    initialize_session_state()
    
    # Apply custom styling
    apply_custom_css()
    
    # Render sidebar navigation
    render_sidebar()
    
    # Render the appropriate page based on session state
    if st.session_state.page == "settings":
        render_settings_tab()
    elif st.session_state.page == "flashcards":
        render_flashcards_interface()
    elif st.session_state.page == "multiplayer":
        render_multiplayer_interface()
    else:
        render_chat_interface()

================================================================================
File: frontend/middleware.py
Size: 14.99 kB
================================================================================

import requests
from settings.config import settings
from dotenv import load_dotenv
import os
import streamlit as st
import json
from typing import List, Dict, Any, Optional

# Load environment variables from .client_env
load_dotenv(".client_env")

# Get environment variables, with fallbacks
DOMAIN_NAME = os.getenv("DOMAIN_NAME", "localhost")
ROOT_PATH = os.getenv("ROOT_PATH", "")
BACKEND_PORT = os.getenv("BACKEND_PORT", "8090")

def call_backend_test():
    try:
        # Construct URL with proper protocol and format
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/app/test/"
        print(f"Calling backend URL: {url}")

        params = {}
        response = requests.get(url, params=params)
        print(f"Response status: {response.status_code}")
        return response.json()
    except Exception as e:
        print(f"Error calling backend: {str(e)}")
        return None

def send_message(message):
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/chat/message/"
        print(f"Sending message to backend URL: {url}")
        
        # Get RAG settings from session state
        rag_enabled = st.session_state.settings["rag"]["enabled"]
        rag_collections = st.session_state.settings["rag"]["collections"] if rag_enabled else []
        top_k = st.session_state.settings["rag"]["top_k"] if rag_enabled else 0
        
        payload = {
            "message": message,
            "rag_config": {
                "enabled": rag_enabled,
                "collections": rag_collections,
                "top_k": top_k
            }
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            response_data = response.json()
            # Extract token metrics and response time if available
            metrics = response_data.get("metrics", {
                "input_tokens": 0,
                "output_tokens": 0,
                "total_tokens": 0,
                "response_time": 0
            })
            
            return {
                "response": response_data.get("response", "No response received"),
                "metrics": metrics
            }
        else:
            print(f"Error from backend: {response.text}")
            return {
                "response": f"Error: {response.status_code}",
                "metrics": {
                    "input_tokens": 0,
                    "output_tokens": 0,
                    "total_tokens": 0,
                    "response_time": 0
                }
            }
    except Exception as e:
        print(f"Error sending message to backend: {str(e)}")
        return {
            "response": f"Connection error: {str(e)}",
            "metrics": {
                "input_tokens": 0,
                "output_tokens": 0,
                "total_tokens": 0,
                "response_time": 0
            }
        }

def save_chat_history(history):
    """
    Save the current chat history to the backend
    
    Args:
        history: List of chat messages with role, content, and timestamp
        
    Returns:
        dict: Status of the operation
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/chat/history/save/"
        print(f"Saving chat history to backend URL: {url}")
        
        payload = {
            "history": history
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error saving chat history: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def submit_feedback(message_id, rating, comments=None):
    """
    Submit user feedback about a specific message
    
    Args:
        message_id: Unique identifier for the message
        rating: Numeric rating (typically 1-5)
        comments: Optional feedback comments
        
    Returns:
        dict: Status of the operation
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/chat/feedback/"
        print(f"Submitting feedback to backend URL: {url}")
        
        payload = {
            "message_id": message_id,
            "rating": rating,
            "comments": comments
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error submitting feedback: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def update_preferences(preferences):
    """
    Update user preferences on the backend
    
    Args:
        preferences: Dictionary containing user preferences
        
    Returns:
        dict: Status of the operation
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/chat/preferences/"
        print(f"Updating preferences to backend URL: {url}")
        
        response = requests.post(url, json=preferences)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error updating preferences: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def rag_direct_query(query, collection_name, top_k=3):
    """
    Send a direct query to the RAG system without generating a response
    
    Args:
        query: The search query
        collection_name: Name of the collection to search
        top_k: Number of results to return
        
    Returns:
        dict: Query results
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/chat/rag/query/"
        print(f"Sending RAG query to backend URL: {url}")
        
        payload = {
            "query": query,
            "collection_name": collection_name,
            "top_k": top_k
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json().get("data", {})
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error with RAG query: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def create_rag_collection(collection_name: str):
    """
    Create a new RAG collection
    
    Args:
        collection_name: Name of the collection to create
        
    Returns:
        dict: Status of the operation
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/rag/collections/create/"
        print(f"Creating new RAG collection: {collection_name}")
        
        payload = {
            "name": collection_name
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error creating collection: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def add_document_to_collection(file, collection_name: str, model: str, chunk_size=None, chunk_overlap=None):
    """
    Add a document to a RAG collection
    
    Args:
        file: File object to upload
        collection_name: Target collection
        model: Embedding model to use
        chunk_size: Optional size of text chunks
        chunk_overlap: Optional overlap between chunks
        
    Returns:
        dict: Status of the operation
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/rag/documents/add/"
        print(f"Adding document to collection: {collection_name}")
        
        # Prepare form data
        files = {'document': file}
        data = {'collection_name': collection_name, 'model': model}
        
        # Add optional parameters if provided
        if chunk_size:
            data['chunk_size'] = chunk_size
        if chunk_overlap:
            data['chunk_overlap'] = chunk_overlap
        
        response = requests.post(url, files=files, data=data)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error adding document: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def get_query_embeddings(query: str, collection_name: str):
    """
    Generate embeddings for a text query
    
    Args:
        query: Text to embed
        collection_name: Collection determining the embedding model
        
    Returns:
        dict: Embedding vector
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/rag/embeddings/"
        print(f"Getting embeddings for query in collection: {collection_name}")
        
        payload = {
            "query": query,
            "collection_name": collection_name
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json().get("data", {})
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error generating embeddings: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def retrieve_rag_answer(query: str, model_family: str, model_name: str, 
                       prompt: str, collection_name: str, history_data: str = "[]"):
    """
    Retrieve an answer using RAG
    
    Args:
        query: User's question
        model_family: LLM provider (mistral, openai, etc.)
        model_name: Specific model to use
        prompt: System prompt template
        collection_name: Knowledge base to query
        history_data: Conversation history as JSON string
        
    Returns:
        dict: Generated answer and metadata
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/rag/retrieve-answer/"
        print(f"Retrieving RAG answer for query: {query}")
        
        payload = {
            "query": query,
            "model_family": model_family,
            "model_name": model_name,
            "prompt": prompt,
            "collection_name": collection_name,
            "history_data": history_data
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json().get("data", {})
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error retrieving RAG answer: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def analyze_difficult_flashcards(cards: List[Dict[str, Any]]):
    """
    Analyze flashcards to identify those with poor performance
    
    Args:
        cards: List of flashcards with review history
        
    Returns:
        dict: Analysis results with difficult cards
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/flashcards/analyze/"
        print(f"Analyzing flashcards for difficulty")
        
        payload = {
            "cards": cards
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json().get("data", {})
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error analyzing flashcards: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}

def generate_ai_flashcards(difficult_cards: List[Dict[str, Any]], num_to_generate: int = 3, 
                         difficulty_level: str = "medium", generation_strategy: str = "related"):
    """
    Generate new flashcards using AI based on difficult cards
    
    Args:
        difficult_cards: List of flashcards identified as difficult
        num_to_generate: Number of cards to generate
        difficulty_level: Desired difficulty level (easy, medium, hard)
        generation_strategy: Strategy for generation (related, breakdown, alternative)
        
    Returns:
        dict: Generation results with new cards
    """
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/flashcards/generate/"
        print(f"Generating AI flashcards: {num_to_generate} cards at {difficulty_level} difficulty using {generation_strategy} strategy")
        
        payload = {
            "difficult_cards": difficult_cards,
            "num_to_generate": num_to_generate,
            "difficulty_level": difficulty_level,
            "generation_strategy": generation_strategy
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json().get("data", {})
        else:
            print(f"Error from backend: {response.text}")
            return {"status": "error", "message": f"Error: {response.status_code}"}
    except Exception as e:
        print(f"Error generating flashcards: {str(e)}")
        return {"status": "error", "message": f"Connection error: {str(e)}"}


================================================================================
File: frontend/multiplayer.py
Size: 38.58 kB
================================================================================

import streamlit as st
import time
import json
from datetime import datetime
import random
import uuid
from pathlib import Path
import requests
import base64
import os
from io import BytesIO
from PIL import Image
import asyncio
import websockets
import threading

# Import middleware functions
from frontend.middleware import call_backend_test
from settings.config import settings
from dotenv import load_dotenv

# Load environment variables
load_dotenv(".client_env")

# Get environment variables, with fallbacks
DOMAIN_NAME = os.getenv("DOMAIN_NAME", "localhost")
ROOT_PATH = os.getenv("ROOT_PATH", "")
BACKEND_PORT = os.getenv("BACKEND_PORT", "8090")

# Initialize multiplayer-related session state variables
def init_multiplayer_state():
    """Initialize multiplayer-related session state variables"""
    # Main state for multiplayer UI
    if "multiplayer_state" not in st.session_state:
        st.session_state.multiplayer_state = "lobby"  # lobby, waiting_room, game_view, scoreboard_view, results_view
    
    # User credentials and game info
    if "nickname" not in st.session_state:
        st.session_state.nickname = ""
    if "game_code" not in st.session_state:
        st.session_state.game_code = ""
    if "host_id" not in st.session_state:
        st.session_state.host_id = ""
    if "player_id" not in st.session_state:
        st.session_state.player_id = ""
    if "is_host" not in st.session_state:
        st.session_state.is_host = False
    
    # Game data
    if "players" not in st.session_state:
        st.session_state.players = []
    if "current_question" not in st.session_state:
        st.session_state.current_question = None
    if "timer_duration" not in st.session_state:
        st.session_state.timer_duration = 20  # seconds
    if "round_start_time" not in st.session_state:
        st.session_state.round_start_time = None
    if "answered_this_round" not in st.session_state:
        st.session_state.answered_this_round = False
    if "scoreboard_data" not in st.session_state:
        st.session_state.scoreboard_data = None
    if "game_results" not in st.session_state:
        st.session_state.game_results = None
    
    # WebSocket connection
    if "ws_connected" not in st.session_state:
        st.session_state.ws_connected = False
    if "ws_messages" not in st.session_state:
        st.session_state.ws_messages = []
    if "ws_last_update" not in st.session_state:
        st.session_state.ws_last_update = datetime.now()

def switch_to_multiplayer():
    """Switch to the multiplayer page"""
    st.session_state.page = "multiplayer"

def switch_to_chat():
    """Switch to the chat page"""
    st.session_state.page = "chat"

def switch_to_flashcards():
    """Switch to the flashcards page"""
    st.session_state.page = "flashcards"

def apply_custom_multiplayer_css():
    """Apply custom CSS for the multiplayer interface"""
    st.markdown("""
    <style>
    /* Game container */
    .game-container {
        background-color: white;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        text-align: center;
    }
    
    /* Lobby styling */
    .lobby-container {
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
    }
    
    /* Waiting room styling */
    .player-list {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
    }
    
    .player-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        margin-bottom: 5px;
        border-radius: 8px;
        background-color: white;
    }
    
    .player-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: #6c4ed4;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        font-weight: bold;
    }
    
    .player-host-badge {
        background-color: #ffd700;
        color: #333;
        font-size: 0.7rem;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 10px;
    }
    
    /* Game code display */
    .game-code-display {
        background-color: #f0f4f9;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        text-align: center;
        font-size: 1.5rem;
        font-weight: bold;
        letter-spacing: 5px;
        color: #333;
    }
    
    /* Question styling */
    .question-container {
        background-color: white;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        text-align: center;
    }
    
    .question-text {
        font-size: 1.5rem;
        font-weight: 500;
        color: #333;
        margin-bottom: 20px;
    }
    
    /* Timer */
    .timer-container {
        margin: 20px 0;
    }
    
    .timer-bar {
        height: 10px;
        border-radius: 5px;
        background: linear-gradient(90deg, #4A76F9 0%, #6c4ed4 100%);
    }
    
    /* Answer options */
    .answer-option {
        background-color: #f0f4f9;
        border: 2px solid #4A76F9;
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .answer-option:hover {
        background-color: #e0e8f9;
        transform: translateY(-2px);
    }
    
    .answered {
        background-color: #d1d1d1;
        border-color: #999;
        color: #666;
        pointer-events: none;
    }
    
    /* Scoreboard */
    .scoreboard-container {
        background-color: white;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    
    .scoreboard-title {
        font-size: 1.8rem;
        font-weight: 600;
        color: #333;
        margin-bottom: 20px;
        text-align: center;
    }
    
    .player-score-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 15px;
        margin-bottom: 10px;
        border-radius: 8px;
        background-color: #f8f9fa;
    }
    
    .player-rank {
        font-weight: bold;
        font-size: 1.2rem;
        margin-right: 15px;
        color: #666;
    }
    
    .player-score {
        font-weight: bold;
        font-size: 1.1rem;
        color: #4A76F9;
    }
    
    .player-score-change {
        font-size: 0.9rem;
        padding: 3px 8px;
        border-radius: 10px;
        margin-left: 10px;
    }
    
    .score-increased {
        background-color: #d4f7d4;
        color: #28a745;
    }
    
    .score-unchanged {
        background-color: #f7f7d7;
        color: #ffc107;
    }
    
    /* Results view */
    .results-container {
        background-color: white;
        border-radius: 12px;
        padding: 30px;
        margin: 20px 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        text-align: center;
    }
    
    .results-title {
        font-size: 2rem;
        font-weight: 600;
        color: #6c4ed4;
        margin-bottom: 30px;
    }
    
    .winner-badge {
        background-color: #ffd700;
        color: #333;
        font-size: 0.9rem;
        padding: 3px 8px;
        border-radius: 10px;
        margin-left: 10px;
    }
    
    /* Connection status */
    .connection-status {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 20px;
        font-size: 0.8rem;
        z-index: 1000;
    }
    
    .connected {
        background-color: #d4f7d4;
        color: #28a745;
    }
    
    .disconnected {
        background-color: #f7d4d4;
        color: #dc3545;
    }
    </style>
    """, unsafe_allow_html=True)

# WebSocket connection handling
def setup_websocket_connection():
    """Setup WebSocket connection in a separate thread"""
    if st.session_state.ws_connected:
        return  # Already connected
    
    if not st.session_state.game_code or not st.session_state.nickname:
        return  # Missing required data
    
    # Start WebSocket connection in a separate thread
    def websocket_thread():
        asyncio.run(connect_to_websocket())
    
    thread = threading.Thread(target=websocket_thread)
    thread.daemon = True
    thread.start()

async def connect_to_websocket():
    """Connect to the WebSocket server"""
    ws_url = f"ws://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/multiplayer/ws/{st.session_state.game_code}/{st.session_state.nickname}"
    
    try:
        async with websockets.connect(ws_url) as websocket:
            st.session_state.ws_connected = True
            
            # Listen for messages
            while True:
                try:
                    message = await websocket.recv()
                    handle_websocket_message(message)
                except websockets.exceptions.ConnectionClosed:
                    st.session_state.ws_connected = False
                    break
    except Exception as e:
        st.session_state.ws_connected = False
        print(f"WebSocket error: {e}")

def handle_websocket_message(message):
    """Handle incoming WebSocket messages"""
    try:
        # Parse the message
        data = json.loads(message)
        event_type = data.get("event")
        
        # Add to messages queue
        st.session_state.ws_messages.append(data)
        st.session_state.ws_last_update = datetime.now()
        
        # Handle different event types
        if event_type == "player_joined":
            st.session_state.players = data.get("players", [])
        
        elif event_type == "player_left":
            st.session_state.players = data.get("players", [])
        
        elif event_type == "game_started":
            st.session_state.multiplayer_state = "game_view"
        
        elif event_type == "new_question":
            st.session_state.current_question = data.get("question", {})
            st.session_state.timer_duration = data.get("timer_duration", 20)
            st.session_state.round_start_time = datetime.now()
            st.session_state.answered_this_round = False
            st.session_state.multiplayer_state = "game_view"
        
        elif event_type == "show_scoreboard":
            st.session_state.scoreboard_data = data.get("scoreboard", {})
            st.session_state.multiplayer_state = "scoreboard_view"
        
        elif event_type == "game_over":
            st.session_state.game_results = data.get("results", {})
            st.session_state.multiplayer_state = "results_view"
        
    except Exception as e:
        print(f"Error handling WebSocket message: {e}")

# API client functions for multiplayer
def create_game(host_nickname, flashcards_content):
    """Create a new multiplayer game"""
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/multiplayer/create"
        print(f"Creating game at URL: {url}")
        
        payload = {
            "host_nickname": host_nickname,
            "flashcards_content": flashcards_content
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {
                "status": "error",
                "message": f"Error: {response.status_code}"
            }
    except Exception as e:
        print(f"Error creating game: {str(e)}")
        return {
            "status": "error",
            "message": f"Connection error: {str(e)}"
        }

def join_game(game_code, nickname):
    """Join an existing multiplayer game"""
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/multiplayer/join"
        print(f"Joining game at URL: {url}")
        
        payload = {
            "game_code": game_code,
            "nickname": nickname
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {
                "status": "error",
                "message": f"Error: {response.status_code}"
            }
    except Exception as e:
        print(f"Error joining game: {str(e)}")
        return {
            "status": "error",
            "message": f"Connection error: {str(e)}"
        }

def start_game(game_code, host_id):
    """Start a multiplayer game"""
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/multiplayer/start"
        print(f"Starting game at URL: {url}")
        
        payload = {
            "game_code": game_code,
            "host_id": host_id
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {
                "status": "error",
                "message": f"Error: {response.status_code}"
            }
    except Exception as e:
        print(f"Error starting game: {str(e)}")
        return {
            "status": "error",
            "message": f"Connection error: {str(e)}"
        }

def submit_answer(game_code, player_id, answer, time_taken):
    """Submit an answer for the current question"""
    try:
        url = f"http://{DOMAIN_NAME}:{BACKEND_PORT}{ROOT_PATH}/api/multiplayer/answer"
        print(f"Submitting answer to URL: {url}")
        
        payload = {
            "game_code": game_code,
            "player_id": player_id,
            "answer": answer,
            "time_taken": time_taken
        }
        
        response = requests.post(url, json=payload)
        print(f"Response status: {response.status_code}")
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error from backend: {response.text}")
            return {
                "status": "error",
                "message": f"Error: {response.status_code}"
            }
    except Exception as e:
        print(f"Error submitting answer: {str(e)}")
        return {
            "status": "error",
            "message": f"Connection error: {str(e)}"
        }

# UI Components for each state
def render_lobby():
    """Render the lobby UI for joining or creating a game"""
    st.markdown("""
    <div style="text-align: center; margin-bottom: 20px;">
        <h1 style="color: #6c4ed4;">🎮 Multiplayer Flashcards</h1>
        <p>Play flashcard games with friends in real-time!</p>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2 = st.columns(2)
    
    # Create Game Form
    with col1:
        st.markdown('<div class="lobby-container">', unsafe_allow_html=True)
        st.markdown('<h2>Create a Game</h2>', unsafe_allow_html=True)
        
        nickname = st.text_input("Your Nickname", key="create_nickname", placeholder="Enter your nickname...")
        
        # File uploader for flashcards.json
        uploaded_file = st.file_uploader("Upload Flashcards (JSON file)", type=["json"])
        
        if st.button("Create Game", key="create_game_btn", use_container_width=True, disabled=not (nickname and uploaded_file)):
            if nickname and uploaded_file:
                try:
                    # Read the uploaded flashcards file
                    flashcards_content = json.load(uploaded_file)
                    
                    # Call API to create game
                    result = create_game(nickname, flashcards_content)
                    
                    if result.get("status") != "error":
                        # Store game information in session state
                        st.session_state.game_code = result.get("game_code")
                        st.session_state.host_id = result.get("host_id")
                        st.session_state.nickname = nickname
                        st.session_state.is_host = True
                        st.session_state.player_id = result.get("player_id")
                        
                        # Switch to waiting room
                        st.session_state.multiplayer_state = "waiting_room"
                        st.rerun()
                    else:
                        st.error(f"Failed to create game: {result.get('message')}")
                except Exception as e:
                    st.error(f"Error creating game: {str(e)}")
        
        st.markdown('</div>', unsafe_allow_html=True)
    
    # Join Game Form
    with col2:
        st.markdown('<div class="lobby-container">', unsafe_allow_html=True)
        st.markdown('<h2>Join a Game</h2>', unsafe_allow_html=True)
        
        join_nickname = st.text_input("Your Nickname", key="join_nickname", placeholder="Enter your nickname...")
        join_code = st.text_input("Game Code", key="join_code", placeholder="Enter the game code...", max_chars=6)
        
        if st.button("Join Game", key="join_game_btn", use_container_width=True, disabled=not (join_nickname and join_code)):
            if join_nickname and join_code:
                # Call API to join game
                result = join_game(join_code, join_nickname)
                
                if result.get("status") != "error":
                    # Store game information in session state
                    st.session_state.game_code = join_code
                    st.session_state.nickname = join_nickname
                    st.session_state.is_host = False
                    st.session_state.player_id = result.get("player_id")
                    
                    # Switch to waiting room
                    st.session_state.multiplayer_state = "waiting_room"
                    st.rerun()
                else:
                    st.error(f"Failed to join game: {result.get('message')}")
        
        st.markdown('</div>', unsafe_allow_html=True)
    
    # Game instructions
    st.markdown("""
    <div style="background-color: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 30px;">
        <h3 style="color: #333;">How to Play</h3>
        <ol>
            <li><b>Create a Game:</b> Upload your flashcards JSON file and create a game.</li>
            <li><b>Share the Code:</b> Send the game code to your friends.</li>
            <li><b>Answer Questions:</b> The faster you answer correctly, the more points you earn!</li>
        </ol>
    </div>
    """, unsafe_allow_html=True)

def render_waiting_room():
    """Render the waiting room UI while waiting for players"""
    # Setup WebSocket connection if not connected
    if not st.session_state.ws_connected:
        setup_websocket_connection()
    
    # Header
    st.markdown("""
    <div style="text-align: center; margin-bottom: 20px;">
        <h1 style="color: #6c4ed4;">Waiting Room</h1>
        <p>Waiting for players to join...</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Game code display
    st.markdown(f"""
    <div class="game-code-display">
        Game Code: {st.session_state.game_code}
    </div>
    """, unsafe_allow_html=True)
    
    # Connection status
    status_class = "connected" if st.session_state.ws_connected else "disconnected"
    status_text = "Connected" if st.session_state.ws_connected else "Disconnected"
    st.markdown(f"""
    <div class="connection-status {status_class}">
        {status_text}
    </div>
    """, unsafe_allow_html=True)
    
    # Player list
    st.markdown('<h3>Players</h3>', unsafe_allow_html=True)
    st.markdown('<div class="player-list">', unsafe_allow_html=True)
    
    if st.session_state.players:
        for player in st.session_state.players:
            is_host = player.get("id") == st.session_state.host_id
            player_name = player.get("nickname", "Unknown")
            
            st.markdown(f"""
            <div class="player-item">
                <div class="player-avatar">{player_name[0].upper()}</div>
                <div style="flex-grow: 1;">{player_name}</div>
                {f'<div class="player-host-badge">Host</div>' if is_host else ''}
            </div>
            """, unsafe_allow_html=True)
    else:
        st.markdown('<div style="text-align: center; padding: 20px; color: #666;">Waiting for players to join...</div>', unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Start game button (for host only)
    if st.session_state.is_host:
        if len(st.session_state.players) >= 1:  # At least one player to start (normally would be 2+)
            if st.button("Start Game", key="start_game_btn", use_container_width=True):
                # Call API to start the game
                result = start_game(st.session_state.game_code, st.session_state.host_id)
                
                if result.get("status") == "error":
                    st.error(f"Failed to start game: {result.get('message')}")
        else:
            st.button("Start Game", key="start_game_btn", use_container_width=True, disabled=True,
                    help="Need at least 2 players to start the game")
    
    # Back to lobby button
    if st.button("Leave Game", key="leave_game_btn", use_container_width=True):
        # Reset session state
        st.session_state.multiplayer_state = "lobby"
        st.session_state.ws_connected = False
        st.session_state.game_code = ""
        st.session_state.host_id = ""
        st.session_state.nickname = ""
        st.session_state.is_host = False
        st.session_state.player_id = ""
        st.session_state.players = []
        st.rerun()
    
    # Periodically check for new WebSocket messages
    if st.session_state.ws_connected:
        # Rerun every second to check for new messages
        time_since_update = (datetime.now() - st.session_state.ws_last_update).total_seconds()
        if time_since_update > 1.0:
            time.sleep(0.1)
            st.rerun()

def render_game_view():
    """Render the game view UI during active gameplay"""
    # Header
    st.markdown("""
    <div style="text-align: center; margin-bottom: 20px;">
        <h1 style="color: #6c4ed4;">Game in Progress</h1>
    </div>
    """, unsafe_allow_html=True)
    
    # Check if we have a current question
    if not st.session_state.current_question:
        st.markdown("""
        <div style="text-align: center; padding: 30px;">
            <p>Waiting for the next question...</p>
            <div class="typing-animation">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Check for updates every second
        time.sleep(1)
        st.rerun()
        return
    
    # Get question data
    question_text = st.session_state.current_question.get("question", "Question not available")
    answer = st.session_state.current_question.get("answer", "")
    options = st.session_state.current_question.get("options", [])
    question_id = st.session_state.current_question.get("id", "")
    
    # Calculate remaining time
    remaining_time = 0
    if st.session_state.round_start_time:
        elapsed_seconds = (datetime.now() - st.session_state.round_start_time).total_seconds()
        remaining_time = max(0, st.session_state.timer_duration - elapsed_seconds)
        time_percentage = max(0, min(100, (remaining_time / st.session_state.timer_duration) * 100))
    
    # Display the question and timer
    st.markdown(f"""
    <div class="question-container">
        <div class="question-text">{question_text}</div>
        
        <div class="timer-container">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>Time remaining</span>
                <span>{int(remaining_time)} seconds</span>
            </div>
            <div style="background-color: #eee; border-radius: 5px; height: 10px; width: 100%;">
                <div class="timer-bar" style="width: {time_percentage}%;"></div>
            </div>
        </div>
    """, unsafe_allow_html=True)
    
    # Display answer options if available, otherwise show text input
    answer_submitted = False
    
    if st.session_state.answered_this_round:
        st.markdown("""
        <div style="text-align: center; margin: 20px 0;">
            <div style="background-color: #d4f7d4; color: #28a745; padding: 10px; border-radius: 8px;">
                <p style="margin: 0;">Your answer has been submitted!</p>
                <p style="margin: 5px 0 0 0; font-size: 0.9rem;">Waiting for other players...</p>
            </div>
        </div>
        """, unsafe_allow_html=True)
    else:
        if options:
            # Multiple choice question
            st.markdown("</div>", unsafe_allow_html=True)  # Close the question container
            
            for i, option in enumerate(options):
                btn_key = f"option_{i}"
                if st.button(option, key=btn_key, use_container_width=True, 
                           disabled=st.session_state.answered_this_round):
                    # Submit answer
                    time_taken = (datetime.now() - st.session_state.round_start_time).total_seconds()
                    submit_answer(st.session_state.game_code, st.session_state.player_id, option, time_taken)
                    
                    # Update state
                    st.session_state.answered_this_round = True
                    st.rerun()
        else:
            # Text input question
            text_answer = st.text_input("Your Answer", key="text_answer", 
                                      disabled=st.session_state.answered_this_round)
            
            if st.button("Submit Answer", key="submit_answer_btn", use_container_width=True, 
                       disabled=st.session_state.answered_this_round or not text_answer.strip()):
                if text_answer.strip():
                    # Submit answer
                    time_taken = (datetime.now() - st.session_state.round_start_time).total_seconds()
                    submit_answer(st.session_state.game_code, st.session_state.player_id, text_answer, time_taken)
                    
                    # Update state
                    st.session_state.answered_this_round = True
                    st.rerun()
            
            st.markdown("</div>", unsafe_allow_html=True)  # Close the question container
    
    # Player status
    st.markdown('<h3 style="margin-top: 20px;">Players</h3>', unsafe_allow_html=True)
    st.markdown('<div class="player-list">', unsafe_allow_html=True)
    
    if st.session_state.players:
        for player in st.session_state.players:
            player_name = player.get("nickname", "Unknown")
            answered = player.get("answered_this_round", False)
            score = player.get("score", 0)
            
            status_text = "✓ Answered" if answered else "Thinking..."
            status_color = "#28a745" if answered else "#ffc107"
            
            st.markdown(f"""
            <div class="player-item">
                <div class="player-avatar">{player_name[0].upper()}</div>
                <div style="flex-grow: 1;">{player_name}</div>
                <div style="color: {status_color};">{status_text}</div>
                <div style="margin-left: 15px; font-weight: bold;">{score} pts</div>
            </div>
            """, unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Auto-refresh to update timer
    if remaining_time > 0 and not st.session_state.answered_this_round:
        time.sleep(0.1)
        st.rerun()
    
    # Periodically check for new WebSocket messages
    if st.session_state.ws_connected:
        # Rerun every second to check for new messages
        time_since_update = (datetime.now() - st.session_state.ws_last_update).total_seconds()
        if time_since_update > 1.0:
            time.sleep(0.5)
            st.rerun()

def render_scoreboard_view():
    """Render the scoreboard view UI between questions"""
    # Header
    st.markdown("""
    <div style="text-align: center; margin-bottom: 20px;">
        <h1 style="color: #6c4ed4;">Round Results</h1>
    </div>
    """, unsafe_allow_html=True)
    
    # Make sure we have scoreboard data
    if not st.session_state.scoreboard_data:
        st.markdown("""
        <div style="text-align: center; padding: 30px;">
            <p>Loading results...</p>
            <div class="typing-animation">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Check for updates every second
        time.sleep(1)
        st.rerun()
        return
    
    # Display correct answer
    correct_answer = st.session_state.scoreboard_data.get("correct_answer", "Not available")
    
    st.markdown(f"""
    <div style="background-color: #d4f7d4; color: #28a745; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
        <h3 style="margin: 0; color: #28a745;">Correct Answer:</h3>
        <p style="font-size: 1.2rem; margin-top: 5px;">{correct_answer}</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Display player scores
    st.markdown('<div class="scoreboard-container">', unsafe_allow_html=True)
    st.markdown('<h2 class="scoreboard-title">Current Standings</h2>', unsafe_allow_html=True)
    
    player_rankings = st.session_state.scoreboard_data.get("player_rankings", [])
    
    if player_rankings:
        for i, player in enumerate(player_rankings):
            player_name = player.get("nickname", "Unknown")
            score = player.get("score", 0)
            score_change = player.get("score_change", 0)
            
            score_change_class = "score-increased" if score_change > 0 else "score-unchanged"
            score_change_text = f"+{score_change}" if score_change > 0 else "0"
            
            st.markdown(f"""
            <div class="player-score-item">
                <div style="display: flex; align-items: center;">
                    <div class="player-rank">#{i+1}</div>
                    <div class="player-avatar">{player_name[0].upper()}</div>
                    <div>{player_name}</div>
                </div>
                <div style="display: flex; align-items: center;">
                    <div class="player-score">{score}</div>
                    <div class="player-score-change {score_change_class}">{score_change_text}</div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.markdown('<p style="text-align: center;">No player data available</p>', unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Heading to next question message
    st.markdown("""
    <div style="text-align: center; margin-top: 20px; padding: 15px; background-color: #f0f4f9; border-radius: 8px;">
        <p>Next question in a few seconds...</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Periodically check for new WebSocket messages
    if st.session_state.ws_connected:
        # Rerun every second to check for new messages
        time_since_update = (datetime.now() - st.session_state.ws_last_update).total_seconds()
        if time_since_update > 1.0:
            time.sleep(0.5)
            st.rerun()

def render_results_view():
    """Render the final results view UI at the end of the game"""
    # Header
    st.markdown("""
    <div style="text-align: center; margin-bottom: 20px;">
        <h1 style="color: #6c4ed4;">Game Over!</h1>
        <p>Final Results</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Make sure we have results data
    if not st.session_state.game_results:
        st.markdown("""
        <div style="text-align: center; padding: 30px;">
            <p>Loading final results...</p>
            <div class="typing-animation">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Check for updates every second
        time.sleep(1)
        st.rerun()
        return
    
    # Display winner
    final_rankings = st.session_state.game_results.get("final_rankings", [])
    
    if final_rankings and len(final_rankings) > 0:
        winner = final_rankings[0]
        winner_name = winner.get("nickname", "Unknown")
        winner_score = winner.get("score", 0)
        
        st.markdown(f"""
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="background-color: #ffd700; display: inline-block; width: 80px; height: 80px; border-radius: 50%; margin-bottom: 15px;">
                <div style="line-height: 80px; font-size: 40px;">🏆</div>
            </div>
            <h2 style="margin: 0; color: #333;">{winner_name}</h2>
            <p style="font-size: 1.2rem; margin: 5px 0;">{winner_score} points</p>
        </div>
        """, unsafe_allow_html=True)
    
    # Display final rankings
    st.markdown('<div class="results-container">', unsafe_allow_html=True)
    st.markdown('<h2 class="results-title">Final Standings</h2>', unsafe_allow_html=True)
    
    if final_rankings:
        for i, player in enumerate(final_rankings):
            player_name = player.get("nickname", "Unknown")
            score = player.get("score", 0)
            
            winner_badge = '<div class="winner-badge">Winner!</div>' if i == 0 else ''
            
            st.markdown(f"""
            <div class="player-score-item">
                <div style="display: flex; align-items: center;">
                    <div class="player-rank">#{i+1}</div>
                    <div class="player-avatar">{player_name[0].upper()}</div>
                    <div>{player_name}{winner_badge}</div>
                </div>
                <div class="player-score">{score}</div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.markdown('<p style="text-align: center;">No player data available</p>', unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Game stats
    game_stats = st.session_state.game_results.get("game_stats", {})
    
    st.markdown("""
    <div style="background-color: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px;">
        <h3 style="color: #333; margin-bottom: 15px;">Game Statistics</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
    """, unsafe_allow_html=True)
    
    questions_count = game_stats.get("questions_count", 0)
    st.markdown(f"""
    <div style="background-color: white; padding: 15px; border-radius: 8px; text-align: center;">
        <div style="font-size: 1.5rem; font-weight: bold; color: #6c4ed4;">{questions_count}</div>
        <div style="color: #666;">Questions</div>
    </div>
    """, unsafe_allow_html=True)
    
    players_count = game_stats.get("players_count", 0)
    st.markdown(f"""
    <div style="background-color: white; padding: 15px; border-radius: 8px; text-align: center;">
        <div style="font-size: 1.5rem; font-weight: bold; color: #6c4ed4;">{players_count}</div>
        <div style="color: #666;">Players</div>
    </div>
    """, unsafe_allow_html=True)
    
    game_duration = game_stats.get("game_duration", "0m 0s")
    st.markdown(f"""
    <div style="background-color: white; padding: 15px; border-radius: 8px; text-align: center;">
        <div style="font-size: 1.5rem; font-weight: bold; color: #6c4ed4;">{game_duration}</div>
        <div style="color: #666;">Duration</div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Action buttons
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("Play Again", key="play_again_btn", use_container_width=True):
            # Reset session state
            st.session_state.multiplayer_state = "lobby"
            st.session_state.ws_connected = False
            st.session_state.game_code = ""
            st.session_state.host_id = ""
            st.session_state.nickname = ""
            st.session_state.is_host = False
            st.session_state.player_id = ""
            st.session_state.players = []
            st.session_state.current_question = None
            st.session_state.scoreboard_data = None
            st.session_state.game_results = None
            st.rerun()
    
    with col2:
        if st.button("Back to Home", key="back_to_home_btn", use_container_width=True):
            # Reset session state and go back to main page
            st.session_state.multiplayer_state = "lobby"
            st.session_state.ws_connected = False
            st.session_state.page = "chat"  # Back to main chat interface
            st.rerun()

def render_multiplayer_interface():
    """Main function to render the multiplayer interface"""
    # Initialize multiplayer state if needed
    init_multiplayer_state()
    
    # Apply custom CSS
    apply_custom_multiplayer_css()
    
    # Render the appropriate view based on the current state
    if st.session_state.multiplayer_state == "lobby":
        render_lobby()
    elif st.session_state.multiplayer_state == "waiting_room":
        render_waiting_room()
    elif st.session_state.multiplayer_state == "game_view":
        render_game_view()
    elif st.session_state.multiplayer_state == "scoreboard_view":
        render_scoreboard_view()
    elif st.session_state.multiplayer_state == "results_view":
        render_results_view()
    else:
        st.error(f"Unknown multiplayer state: {st.session_state.multiplayer_state}")
        
        # Fallback to lobby
        if st.button("Go to Lobby", use_container_width=True):
            st.session_state.multiplayer_state = "lobby"
            st.rerun()

================================================================================
File: frontend/settings.py
Size: 20.71 kB
================================================================================

import streamlit as st
import os
from pathlib import Path
from rag_api_client import list_collections
from frontend.middleware import update_preferences

def init_settings_state():
    """Initialize settings-related session state variables"""
    if "page" not in st.session_state:
        st.session_state.page = "chat"  # Default to chat page
    
    if "settings" not in st.session_state:
        # Default settings
        st.session_state.settings = {
            "prompt": {
                "system_prompt": "You are a helpful and friendly assistant. Your responses should be concise, informative, and engaging.",
                "temperature": 0.7,
                "max_tokens": 500
            },
            "model": {
                "provider": "mistral",
                "model_name": "mistral-tiny",
                "api_key": os.environ.get("MISTRAL_API_KEY", ""),
                "streaming": True
            },
            "context": {
                "memory_size": 10,  # Number of messages to remember
                "include_timestamps": True,
                "include_system_messages": False
            },
            "rag": {
                "enabled": True,
                "collections": [],
                "available_collections": [],
                "top_k": 3,  # Number of chunks to retrieve from RAG
            },
            "other": {
                "log_conversations": True,
                "enable_feedback": False,
                "show_model_info": True,
                "theme": "light"
            }
        }
        
        # Load available RAG collections when initializing
        try:
            collections = list_collections()
            st.session_state.settings["rag"]["available_collections"] = collections
            # Set default collections to all available
            st.session_state.settings["rag"]["collections"] = collections
        except Exception as e:
            print(f"Failed to load RAG collections: {e}")

def save_settings():
    """Save settings to a file and sync to backend"""
    # Create .streamlit directory if it doesn't exist
    streamlit_dir = Path.home() / ".streamlit"
    streamlit_dir.mkdir(exist_ok=True)
    
    # Create or update config.toml with settings
    # Following the guidelines from README.md about config.toml format
    config_path = Path(".streamlit") / "config.toml"
    config_path.parent.mkdir(exist_ok=True)
    
    with open(config_path, "w") as f:
        # Client settings
        f.write("[client]\n")
        f.write(f"toolbarMode = \"{'minimal' if st.session_state.settings['other']['enable_feedback'] else 'viewer'}\"\n")
        f.write(f"showSidebarNavigation = false\n\n")
        
        # Theme settings
        f.write("[theme]\n")
        f.write(f"base = \"{st.session_state.settings['other']['theme']}\"\n")
        f.write(f"primaryColor = \"#6c4ed4\"\n")
        f.write(f"backgroundColor = \"#f9f9fb\"\n")
        f.write(f"textColor = \"#262730\"\n")
    
    # Send settings to backend
    try:
        response = update_preferences(st.session_state.settings)
        if response.get("status") == "success":
            st.success("Settings saved successfully and synced to backend!")
        else:
            st.warning(f"Settings saved locally but failed to sync with backend: {response.get('message', 'Unknown error')}")
    except Exception as e:
        st.warning(f"Settings saved locally but failed to sync with backend: {str(e)}")
        print(f"Error syncing preferences: {str(e)}")

def switch_to_chat():
    """Switch to the chat page"""
    st.session_state.page = "chat"

def render_settings_tab():
    """Render settings page with tabs"""
    # Apply settings-specific CSS for button styling
    st.markdown("""
    <style>
    /* Custom button styling for Settings page */
    .stButton > button {
        border-radius: 8px !important; 
        padding: 0.5rem 1rem !important; 
        height: auto !important; 
        width: auto !important; 
        min-width: 100px !important; 
        min-height: 44px !important; 
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        font-size: 1rem !important; 
    }
    
    /* Tab button styling */
    .stTabs button {
        font-size: 1rem !important;
        font-weight: 500 !important;
        padding: 0.5rem 1rem !important;
    }
    
    /* Tab content padding */
    .stTabs [data-baseweb="tab-panel"] {
        padding-top: 1rem !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Header
    st.markdown("""
    <div style="text-align: center; padding: 20px 0; animation: fadeIn 1s ease-in;">
        <h1 style="color: #6c4ed4; margin-bottom: 5px;">⚙️ Chatbot Settings</h1>
        <p style="color: #666; font-size: 1rem;">Customize your chatbot experience</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Back button
    st.button("← Back to Chat", key="back_to_chat", on_click=switch_to_chat)
    st.divider()
    
    # Create tabs for different settings categories
    tab_labels = ["Prompt", "Model", "Context", "RAG", "RAG Management", "Other"]
    tabs = st.tabs(tab_labels)
    
    # Prompt Settings Tab
    with tabs[0]:
        st.header("Prompt Settings")
        
        st.session_state.settings["prompt"]["system_prompt"] = st.text_area(
            "System Prompt",
            value=st.session_state.settings["prompt"]["system_prompt"],
            help="The prompt that defines your chatbot's personality and behavior",
            height=150
        )
        
        col1, col2 = st.columns(2)
        with col1:
            st.session_state.settings["prompt"]["temperature"] = st.slider(
                "Temperature",
                min_value=0.0,
                max_value=1.0,
                value=st.session_state.settings["prompt"]["temperature"],
                step=0.1,
                help="Higher values make output more random, lower values more deterministic"
            )
        
        with col2:
            st.session_state.settings["prompt"]["max_tokens"] = st.slider(
                "Max Response Length",
                min_value=100,
                max_value=2000,
                value=st.session_state.settings["prompt"]["max_tokens"],
                step=100,
                help="Maximum number of tokens in the model's response"
            )
    
    # Model Settings Tab
    with tabs[1]:
        st.header("Model Settings")
        
        st.session_state.settings["model"]["provider"] = st.selectbox(
            "Provider",
            options=["mistral", "openai", "anthropic", "local"],
            index=["mistral", "openai", "anthropic", "local"].index(st.session_state.settings["model"]["provider"]),
            help="The AI provider to use for your chatbot"
        )
        
        # Show different model options based on provider
        if st.session_state.settings["model"]["provider"] == "mistral":
            model_options = ["mistral-tiny", "mistral-small", "mistral-medium", "mistral-large"]
            default_index = 0
            if st.session_state.settings["model"]["model_name"] in model_options:
                default_index = model_options.index(st.session_state.settings["model"]["model_name"])
            
            st.session_state.settings["model"]["model_name"] = st.selectbox(
                "Model",
                options=model_options,
                index=default_index,
                help="The specific model to use from the selected provider"
            )
        elif st.session_state.settings["model"]["provider"] == "openai":
            st.session_state.settings["model"]["model_name"] = st.selectbox(
                "Model",
                options=["gpt-3.5-turbo", "gpt-4", "gpt-4-turbo"],
                index=0,
                help="The specific model to use from the selected provider"
            )
        elif st.session_state.settings["model"]["provider"] == "anthropic":
            st.session_state.settings["model"]["model_name"] = st.selectbox(
                "Model",
                options=["claude-3-opus", "claude-3-sonnet", "claude-3-haiku"],
                index=0,
                help="The specific model to use from the selected provider"
            )
        else:  # local
            st.session_state.settings["model"]["model_name"] = st.text_input(
                "Model Path",
                value=st.session_state.settings["model"]["model_name"],
                help="Path to local model"
            )
        
        # API Key input with password masking
        st.session_state.settings["model"]["api_key"] = st.text_input(
            "API Key",
            value=st.session_state.settings["model"]["api_key"],
            type="password",
            help="Your API key for the selected provider"
        )
        
        st.session_state.settings["model"]["streaming"] = st.toggle(
            "Enable Streaming Responses",
            value=st.session_state.settings["model"]["streaming"],
            help="Display responses as they're generated"
        )
    
    # Context Settings Tab
    with tabs[2]:
        st.header("Context Settings")
        
        st.session_state.settings["context"]["memory_size"] = st.slider(
            "Conversation Memory",
            min_value=1,
            max_value=50,
            value=st.session_state.settings["context"]["memory_size"],
            step=1,
            help="Number of previous messages to include in context"
        )
        
        st.session_state.settings["context"]["include_timestamps"] = st.toggle(
            "Include Timestamps",
            value=st.session_state.settings["context"]["include_timestamps"],
            help="Include message timestamps in the context"
        )
        
        st.session_state.settings["context"]["include_system_messages"] = st.toggle(
            "Include System Messages",
            value=st.session_state.settings["context"]["include_system_messages"],
            help="Include system messages in the context"
        )
    
    # RAG Settings Tab
    with tabs[3]:
        st.header("RAG Settings")
        
        st.session_state.settings["rag"]["enabled"] = st.toggle(
            "Enable Retrieval-Augmented Generation",
            value=st.session_state.settings["rag"]["enabled"],
            help="Use document retrieval to enhance chatbot responses"
        )
        
        # Refresh collections button
        if st.button("Refresh Collections", key="refresh_collections"):
            try:
                collections = list_collections()
                st.session_state.settings["rag"]["available_collections"] = collections
                st.success(f"Found {len(collections)} collections")
            except Exception as e:
                st.error(f"Failed to load collections: {str(e)}")
        
        # Only show collection selection if RAG is enabled
        if st.session_state.settings["rag"]["enabled"]:
            # Show available collections
            if "available_collections" in st.session_state.settings["rag"] and st.session_state.settings["rag"]["available_collections"]:
                st.session_state.settings["rag"]["collections"] = st.multiselect(
                    "Select Knowledge Bases",
                    options=st.session_state.settings["rag"]["available_collections"],
                    default=st.session_state.settings["rag"]["collections"],
                    help="Select which document collections to use for RAG"
                )
                
                st.session_state.settings["rag"]["top_k"] = st.slider(
                    "Number of chunks to retrieve",
                    min_value=1,
                    max_value=10,
                    value=st.session_state.settings["rag"]["top_k"],
                    step=1,
                    help="Number of document chunks to retrieve for each query"
                )
            else:
                st.info("No collections available. Click 'Refresh Collections' to fetch available knowledge bases.")
    
    # New RAG Management Tab
    with tabs[4]:
        render_rag_management_tab()
    
    # Other Settings Tab
    with tabs[5]:
        st.header("Other Settings")
        
        st.session_state.settings["other"]["log_conversations"] = st.toggle(
            "Log Conversations",
            value=st.session_state.settings["other"]["log_conversations"],
            help="Save conversation history to logs"
        )
        
        st.session_state.settings["other"]["enable_feedback"] = st.toggle(
            "Enable Feedback Option",
            value=st.session_state.settings["other"]["enable_feedback"],
            help="Allow users to provide feedback on responses"
        )
        
        st.session_state.settings["other"]["show_model_info"] = st.toggle(
            "Show Model Info",
            value=st.session_state.settings["other"]["show_model_info"],
            help="Display model information on the chat interface"
        )
        
        st.session_state.settings["other"]["theme"] = st.selectbox(
            "Theme",
            options=["light", "dark"],
            index=["light", "dark"].index(st.session_state.settings["other"]["theme"]),
            help="UI theme for the chatbot"
        )
    
    # Save and reset buttons
    st.divider()
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Save Settings", type="primary", use_container_width=True):
            save_settings()
    with col2:
        if st.button("Reset to Defaults", use_container_width=True):
            # Reset to defaults by removing settings from session state
            del st.session_state.settings
            init_settings_state()
            st.success("Settings reset to defaults!")
            st.rerun()

def render_rag_management_tab():
    """Render RAG management interface with collection creation and document upload"""
    from frontend.middleware import create_rag_collection, add_document_to_collection
    from rag_api_client import list_collections
    
    st.header("RAG Management")
    
    # Initialize state variables if they don't exist
    if "rag_management_tab" not in st.session_state:
        st.session_state.rag_management_tab = "collections"
    
    # Create navigation pills
    col1, col2, col3 = st.columns([1, 1, 3])
    with col1:
        if st.button("Collections", type="primary" if st.session_state.rag_management_tab == "collections" else "secondary",
                   key="collections_tab", use_container_width=True):
            st.session_state.rag_management_tab = "collections"
            st.rerun()
    
    with col2:
        if st.button("Documents", type="primary" if st.session_state.rag_management_tab == "documents" else "secondary",
                   key="documents_tab", use_container_width=True):
            st.session_state.rag_management_tab = "documents"
            st.rerun()
    
    st.divider()
    
    # Display appropriate tab content
    if st.session_state.rag_management_tab == "collections":
        render_collections_tab()
    else:
        render_documents_tab()

def render_collections_tab():
    """Render the collections management tab"""
    from frontend.middleware import create_rag_collection
    from rag_api_client import list_collections
    
    st.subheader("Manage Collections")
    
    # Display existing collections
    st.markdown("### Existing Collections")
    
    # Refresh collections button
    if st.button("🔄 Refresh Collections", key="refresh_collections_manage"):
        try:
            collections = list_collections()
            st.session_state.settings["rag"]["available_collections"] = collections
            st.success(f"Found {len(collections)} collections")
        except Exception as e:
            st.error(f"Failed to load collections: {str(e)}")
    
    # Show available collections
    if "available_collections" in st.session_state.settings["rag"]:
        collections = st.session_state.settings["rag"]["available_collections"]
        if collections:
            for i, collection in enumerate(collections):
                st.markdown(f"**{i+1}.** {collection}")
        else:
            st.info("No collections found. Create a new one below or refresh the list.")
    else:
        st.info("No collections loaded yet. Click 'Refresh Collections' to fetch the list.")
    
    # Create new collection section
    st.markdown("### Create New Collection")
    with st.form("create_collection_form"):
        new_collection_name = st.text_input("Collection Name", 
                                        placeholder="Enter a name for the new collection")
        submitted = st.form_submit_button("Create Collection")
        
        if submitted and new_collection_name:
            # Call the API to create collection
            response = create_rag_collection(new_collection_name)
            if response.get("status") == "success":
                st.success(f"Collection '{new_collection_name}' created successfully!")
                # Refresh the list of collections
                try:
                    collections = list_collections()
                    st.session_state.settings["rag"]["available_collections"] = collections
                except Exception:
                    pass
            else:
                st.error(f"Failed to create collection: {response.get('message', 'Unknown error')}")

def render_documents_tab():
    """Render the documents management tab"""
    from frontend.middleware import add_document_to_collection
    
    st.subheader("Manage Documents")
    
    # Document upload section
    st.markdown("### Upload Document to Collection")
    
    # Check if we have collections available
    if not st.session_state.settings["rag"].get("available_collections"):
        st.warning("No collections available. Please create or refresh collections in the Collections tab first.")
        return
    
    with st.form("upload_document_form"):
        # Collection selection
        collection_name = st.selectbox(
            "Select Collection",
            options=st.session_state.settings["rag"]["available_collections"],
            help="Choose the collection to add this document to"
        )
        
        # File upload
        uploaded_file = st.file_uploader(
            "Upload Document", 
            type=["pdf", "txt", "docx", "md", "csv"],
            help="Supported formats: PDF, TXT, DOCX, MD, CSV"
        )
        
        # Embedding model selection
        model = st.selectbox(
            "Embedding Model",
            options=["mistral-embed", "text-embedding-ada-002"],
            help="Model to use for generating document embeddings"
        )
        
        # Advanced options expander
        with st.expander("Advanced Options"):
            chunking_col1, chunking_col2 = st.columns(2)
            
            with chunking_col1:
                chunk_size = st.number_input(
                    "Chunk Size",
                    min_value=100,
                    max_value=2000,
                    value=500,
                    step=50,
                    help="Size of text chunks in characters (larger chunks provide more context but less precision)"
                )
            
            with chunking_col2:
                chunk_overlap = st.number_input(
                    "Chunk Overlap",
                    min_value=0,
                    max_value=500,
                    value=50,
                    step=10,
                    help="Overlap between consecutive chunks to maintain context between chunks"
                )
        
        submitted = st.form_submit_button("Upload Document")
        
        if submitted and uploaded_file and collection_name:
            # Show upload in progress indicator
            with st.spinner(f"Uploading document to collection '{collection_name}'..."):
                # Call the API to upload document
                response = add_document_to_collection(
                    file=uploaded_file,
                    collection_name=collection_name,
                    model=model,
                    chunk_size=chunk_size,
                    chunk_overlap=chunk_overlap
                )
                
                if response.get("status") == "success":
                    st.success(f"Document '{uploaded_file.name}' uploaded successfully to collection '{collection_name}'!")
                else:
                    st.error(f"Failed to upload document: {response.get('message', 'Unknown error')}")

================================================================================
File: main_back.py
Size: 1.72 kB
================================================================================

# Import pysqlite3 first
try:
    import pysqlite3
    version = getattr(pysqlite3, "__version__", "unknown")
    print(f"Successfully imported pysqlite3 version: {version}")
except ImportError as e:
    print(f"Error importing pysqlite3: {e}")
    import sys
    print(f"Python path: {sys.path}")
    print(f"Python executable: {sys.executable}")

import uvicorn
import argparse
import os
from backend.app.routes import create_app
from dotenv import set_key

# Store root_path in environment variable for persistence across reloads
ROOT_PATH = os.environ.get("APP_ROOT_PATH", "")

# Create app with root_path
app = create_app(root_path=ROOT_PATH)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run FastAPI server with custom port")
    parser.add_argument("--port", type=int, default=8090, help="Port number to run the server on")
    parser.add_argument("--root_path", type=str, default="", help="The root path where the API is mounted (e.g., /username/app_name)")
    args = parser.parse_args()

    # Update root path from arguments
    if args.root_path:
        os.environ["APP_ROOT_PATH"] = args.root_path
        # Update app root_path for the initial run
        app.root_path = args.root_path

    print(f"Starting server on port {args.port}")
    print(f"Using root_path: {args.root_path}")

    set_key(".client_env", "BACKEND_PORT", str(args.port))
    set_key(".client_env", "ROOT_PATH", args.root_path)

    uvicorn.run(
        "main_back:app",
        host="0.0.0.0",
        port=args.port,
        root_path=args.root_path,
        reload=True,
        log_level="debug",
        #openapi_url=f"{args.root_path}/openapi.json" if args.root_path else "/openapi.json"
    )


================================================================================
File: main_front.py
Size: 70 B
================================================================================

from frontend.main import main

if __name__ == "__main__":
    main()

================================================================================
File: requirements.txt
Size: 160 B
================================================================================

fastapi==0.111.0
pydantic_settings==2.3.4
Requests==2.32.3
streamlit==1.36.0
uvicorn==0.30.1
python-dotenv~=1.0.0
pysqlite3
mistralai==1.6.0
websockets==11.0.3


================================================================================
File: settings/config.py
Size: 553 B
================================================================================

from pydantic_settings import BaseSettings
from typing import List


class Settings(BaseSettings):
    ALLOWED_HOSTS: List[str] = [
        "http://localhost",
    ]
    PROJECT_NAME: str = "Default ForgeAI Application"
    API_VERSION_STR: str = "/api/v1"
    PROJECT_VERSION: str = "0.0.1"
    BASE_URL: str = "http://localhost"
    BACKEND_PORT: int = 8090
    ROOT_PATH: str = ""

    class Config:
        env_file = '.client_env'
        env_file_encoding = 'utf-8'
        env_ignore_empty = True
        extra = "ignore"


settings = Settings()


================================================================================
File: start.sh
Size: 291 B
================================================================================

#!/bin/bash
# Set the domain name environment variable
export DOMAIN_NAME="localhost"

# Run the backend service
python main_back.py --port 1027 > logs/backend.log &

# Give the backend time to start
sleep 2

# Run the frontend using streamlit
streamlit run main_front.py > logs/frontend.log