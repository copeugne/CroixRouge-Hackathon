**Migration Plan: Python/Streamlit/FastAPI to Next.js/tRPC/Supabase/Drizzle**

This plan details the migration from the current Python-based stack (Streamlit frontend, FastAPI backend, JSON file storage) to a modern TypeScript stack using Next.js (App Router), tRPC for APIs, PostgreSQL managed by Supabase, and the Drizzle ORM. It incorporates the specific development commands, tooling, and code style guidelines provided in `CLAUDE.md`.

**Current State:**

*   **Frontend:** Streamlit (`frontend/`) - Reactive UI, `st.session_state` management, HTTP calls via `frontend/middleware.py`, local JSON persistence. Features: Chat, Flashcards (Study, Create, Manage, Stats, AI Assistant), Multiplayer, Settings.
*   **Backend:** FastAPI (`backend/`) - REST API, services for chat, flashcards (Mistral AI generation), RAG interactions (`rag_api_client`), potential basic WebSocket handling.
*   **Database:** JSON files (`flashcards.json`, `flashcard_stats.json`), in-memory storage. **Major limitation.**
*   **AI:** Mistral AI integration.
*   **RAG:** External `rag_api_client`.
*   **Deployment:** Local script (`start.sh`).
*   **Source Code:** The complete previous Python codebase is available in the `python-codebase.txt` file for reference.

**Target State:**

*   **Framework:** Next.js (App Router) ✅ *Installed*
*   **API Layer:** tRPC (End-to-end typesafe APIs) ✅ *Installed*
*   **Database:** PostgreSQL (Managed via Supabase) ✅ *Configured*
*   **ORM/Query Builder:** Drizzle ORM (Typesafe SQL) ✅ *Installed*
*   **Backend Services (Supabase):** Managed PostgreSQL, Authentication, Realtime (WebSockets), Storage (Optional), Edge Functions (Optional).
*   **UI:** React components (e.g., using Shadcn/ui + Tailwind CSS). ✅ *Tailwind installed*
*   **State Management:**
    * TanStack Query (for server state) ✅ *Installed via @tanstack/react-query*
    * Zustand (for client-side UI state) ✅ *Installed*
*   **Validation:** Zod (Schema validation). ✅ *Installed*
*   **Linting/Formatting:** Biome. ✅ *Installed and configured*
*   **Package Manager:** `pnpm`. ✅ *Using pnpm 10.5.2*
*   **AI:** Mistral AI (via Node.js library or direct HTTP). ⏳ *To be installed*
*   **RAG:** Implement our own RAG solution using Supabase Vector. ⏳ *To be implemented*
*   **Deployment:** On my own server ⏳ *To be configured*

---

**Development Workflow & Standards**

*This workflow will be adopted from the start of the migration.*

*   **Package Manager:** Use `pnpm` for all dependency management. ✅ *Configured*
*   **Development Server:** Start the Next.js dev server using `pnpm dev`. ✅ *Configured*
*   **Build & Production Start:** Build the application with `pnpm build` and start the production server with `pnpm start`. ✅ *Configured*
*   **Code Quality:**
    *   Use Biome for consistent formatting and linting. Run checks with `pnpm check`. Fix issues automatically with `pnpm check:write`. ✅ *Configured*
    *   Enforce strict TypeScript settings. Run type checks with `pnpm typecheck`. ✅ *Configured*
*   **Database:**
    *   Manage schema changes using Drizzle Kit. Apply changes to the database using `pnpm db:push`. ✅ *Configured*
    *   Inspect and manage the database during development using `pnpm db:studio`. ✅ *Configured*
*   **Validation:** Use Zod for all data validation (tRPC inputs/outputs, forms). ✅ *Installed*
*   **Code Style:**
    *   Follow TypeScript best practices.
    *   Use PascalCase for React components.
    *   Use camelCase for variables, functions, object keys.
    *   Organize imports (handled automatically by Biome). ✅ *Configured*
    *   Prefer `async/await` for asynchronous code.
*   **API:** Use tRPC for end-to-end type-safe API routes. ✅ *Configured*
*   **Framework:** Adhere to Next.js App Router conventions. ✅ *Configured*
*   **Error Handling:** Implement explicit error handling with proper TypeScript typing.

---

**Migration Plan Phases**

**Phase 0: Preparation & Planning**

1.  **Environment Setup:** ✅ *Completed*
    *   Set up Node.js and `pnpm`. ✅ *Completed*
    *   Create a new Next.js project (App Router) using `pnpm create next-app`. ✅ *Completed*
    *   Set up a Supabase project (enable Database, Auth, Realtime). ✅ *Completed*
    *   Configure local development environment variables in `.env.local`. ✅ *Completed*
    *   Install and configure Biome according to project standards. ✅ *Completed*
    *   Install Zod. ✅ *Completed*
2.  **Detailed Analysis:** ✅ *Completed*
    *   **FastAPI Endpoints:** ✅ *Analyzed*
        * **Main Routers/Prefixes:**
            * `/api/app` - Basic app functionality
            * `/api/chat` - Chat and message processing
            * `/api/rag` - Retrieval-Augmented Generation
            * `/api/flashcards` - Flashcard management
        * **Specific Endpoints:**
            * `/api/chat/message/` (POST) - Process messages with optional RAG
            * `/api/chat/history/save/` (POST) - Save chat history
            * `/api/chat/feedback/` (POST) - Submit ratings and comments
            * `/api/chat/preferences/` (POST) - Update user settings
            * `/api/rag/collections/create/` (POST) - Create RAG collections
            * `/api/rag/documents/add/` (POST) - Upload documents to RAG
            * `/api/rag/embeddings/` (POST) - Generate embeddings
            * `/api/rag/retrieve-answer/` (POST) - Get RAG-enhanced answers
            * `/api/flashcards/analyze/` (POST) - Find difficult cards
            * `/api/flashcards/generate/` (POST) - Generate AI flashcards
        * **Request/Response Models:**
            * `MessageRequest` - Contains `message: str` and optional `rag_config: RAGConfig`
            * `ChatHistoryEntry` - Has `role: str`, `content: str`, `timestamp: Optional[str]`
            * `FeedbackRequest` - Contains `message_id: str`, `rating: int`, `comments: Optional[str]`
            * `UserPreferences` - Dict structures for prompt, model, context, rag settings
            * `FlashcardData` - Complete card model (details below in Schema section)
            * `AnalyzeFlashcardsRequest` - Contains `cards: List[FlashcardData]`
            * `GenerateFlashcardsRequest` - Has difficult cards and generation parameters
            * `RAGConfig` - Contains `enabled: bool`, `collections: List[str]`, `top_k: int`
        * **Error Handling:** Basic try/except patterns with logging and fallback responses
        * **Authentication:** Not implemented in the Python version
    *   **Streamlit UI Components:** ✅ *Analyzed*
        * **Overall Structure:** Tabbed interface with sidebar navigation
        * **Main Components:**
            * **Chat Interface:** Message history display, input field, send button, settings panel
            * **Flashcard Study:** Card display with question/answer toggle, rating buttons (1-4 scale)
            * **Flashcard Creation:** Form with question, answer, optional title, image URL, tags
            * **Flashcard Management:** List view with filters, sorting, edit/delete functions
            * **Flashcard Stats:** Study progress, streak tracking, performance metrics
            * **AI Assistant:** Difficulty analysis, customizable generation with strategy options
            * **Settings:** Application configuration with tabs for different setting categories
        * **State Management:**
            * `st.session_state.flashcards` - List of all user's flashcards
            * `st.session_state.flashcard_stats` - Study statistics and metrics
            * `st.session_state.current_flashcard` - Currently active card in study mode
            * `st.session_state.show_answer` - Boolean toggle for answer visibility
            * `st.session_state.editing_card` - Card being edited in management view
            * `st.session_state.flashcard_settings` - SRS algorithm configuration
            * `st.session_state.reset_flashcard_form` - Flag to reset creation form
        * **Data Flow:** HTTP requests via middleware to FastAPI backend, responses update session state
        * **Component Callbacks:** Functions tied to UI elements for state updates
    *   **SM-2 Algorithm Logic:** ✅ *Analyzed*
        * **Core Parameters:**
            * Initial ease factor: 2.5 (configurable)
            * Initial interval: 1 day (configurable)
            * Repetition counter: Increments on successful reviews, resets on "Again"
            * Rating scale: 1-4 (Again, Hard, Good, Easy)
        * **Algorithm Implementation:**
            * Rating 1 ("Again"): Reset repetitions to 0, set interval to initial (typically 1 day)
            * Rating 2 ("Hard"): Reduce ease factor by 0.15, calculate next interval with reduced ease
            * Rating 3 ("Good"): Keep ease factor, calculate standard interval progression
            * Rating 4 ("Easy"): Increase ease factor by 0.15, calculate interval with bonus
        * **Interval Calculation:**
            * First successful review: Returns fixed interval (typically 1 day)
            * Second successful review: Returns fixed interval (typically 6 days)
            * Subsequent reviews: Interval = current_interval * ease_factor
        * **Ease Factor Update:**
            * Adjusts based on performance: -0.15 for "Hard", +0.15 for "Easy"
            * Bounded to prevent extreme values (typically 1.3 minimum to 2.5+ maximum)
        * **Next Review Date:** Current date + calculated interval in days
    *   **AI Prompt Creation & Response Parsing:** ✅ *Analyzed*
        * **`create_generation_prompt` Function:**
            * **Input Parameters:**
                * `cards_content: List[Dict[str, Any]]` - Difficult cards to base generation on
                * `strategy: str` - "related", "breakdown", or "alternative"
                * `difficulty: str` - "easy", "medium", or "hard"
                * `num_cards: int` - Number of cards to generate
            * **Strategy Definitions:**
                * "related" - Create cards on related topics to reinforce knowledge
                * "breakdown" - Break difficult concepts into simpler, digestible cards
                * "alternative" - Present same information in different ways for better recall
            * **Difficulty Levels:**
                * "easy" - Simpler cards for foundational knowledge
                * "medium" - Moderately challenging cards that extend concepts
                * "hard" - Advanced cards that deepen understanding
            * **Prompt Structure:** System role as educator, difficult card details, formatting instructions with explicit markers
            * **Output Format:** Structured text with card boundaries and field labels
        * **`parse_ai_response` Function:**
            * **Input:** Raw text response from AI
            * **Processing Steps:**
                1. Strip API prefixes if present
                2. Identify card blocks between markers
                3. Extract question and answer fields
                4. Create card objects with metadata (UUID, timestamps)
            * **Output:** List of complete flashcard dictionaries ready for storage
        * **Error Handling:**
            * Fallback card generation with templates if AI fails
            * Logging of all generation attempts and failures
            * Timeout handling
    *   **RAG API Client:** ✅ *Analyzed*
        * **External Import:** `from rag_api_client import get_document_chunks, retrieve_answer, list_collections`
        * **Function Interfaces:**
            * `get_document_chunks(collection_name: str, document_path: str, limit: int)` - Retrieves text chunks
            * `retrieve_answer(query: str, model_family: str, model_name: str, prompt: str, collection_name: str, history_data: str)` - Gets answers with context
            * `list_collections()` - Returns available collections
        * **Integration Points:**
            * Used in chat service to enhance responses with contextual information
            * Exposed through FastAPI endpoints for direct queries and collection management
            * Provides file upload and processing capabilities
        * **Limitations:**
            * External black-box dependency
            * Unknown implementation details
            * Potential compatibility issues with Node.js
        * **Decision Rationale:**
            * Rebuilding with Supabase Vector provides native integration with new stack
            * pgvector extension offers superior performance and scaling
            * Direct DB access simplifies architecture and reduces dependencies
    *   **Database Structure:** ✅ *Analyzed*
        * **Storage Mechanism:**
            * JSON files for persistence across Streamlit sessions:
                * `flashcards.json` - Main flashcard data
                * `flashcard_stats.json` - Study statistics and streak data
                * `flashcard_settings.json` - Algorithm configuration
            * File loading on application start:
                ```python
                cards_file = Path("flashcards.json")
                if cards_file.exists():
                    with open(cards_file, "r") as f:
                        st.session_state.flashcards = json.load(f)
                ```
            * Save operations triggered on data changes:
                ```python
                with open(cards_file, "w") as f:
                    json.dump(st.session_state.flashcards, f, indent=2)
                ```
        * **In-Memory Structures:**
            * Streamlit session state as transient database
            * All operations performed on in-memory objects before persistence
            * Session state cleared on browser refresh (requires reloading files)
        * **Data Access Patterns:**
            * Full load on startup, full save on changes
            * No partial/incremental updates
            * No query language or indexing
            * Linear search for filtering/sorting
        * **Critical Limitations:**
            * No concurrent user support
            * No data validation beyond application logic
            * No referential integrity
            * No backup or transaction support
            * No user-specific data separation
    *   **Flashcard Schema:** ✅ *Analyzed*
        * **Complete JSON Schema:**
            ```json
            {
                "id": "uuid-string",
                "title": "Optional card title",
                "question": "The question text",
                "answer": "The answer text",
                "image_url": "Optional URL to image",
                "created_at": "2023-01-01T12:00:00",
                "tags": ["tag1", "tag2"],
                "repetitions": 0,
                "ease_factor": 2.5,
                "interval": 1,
                "next_review": "2023-01-02T12:00:00",
                "last_review": "2023-01-01T12:00:00",
                "ai_generated": false
            }
            ```
        * **Required Fields:** `id`, `question`, `answer`
        * **Optional Fields:** `title`, `image_url`, `tags`, SRS data
        * **SRS Algorithm Fields:**
            * `repetitions` - Number of successful reviews (integer)
            * `ease_factor` - Difficulty multiplier (float, default 2.5)
            * `interval` - Days until next review (integer)
            * `next_review` - ISO date string for scheduled review
            * `last_review` - ISO date string for previous review
        * **Metadata:**
            * `tags` - Array of string tags for categorization
            * `created_at` - ISO date string for creation timestamp
            * `ai_generated` - Boolean flag for AI-created cards
        * **Stats Schema (Separate File):**
            ```json
            {
                "studied_today": 0,
                "total_studied": 0,
                "correct_today": 0,
                "total_correct": 0,
                "streak": 0,
                "last_study_date": "2023-01-01T12:00:00"
            }
            ```
    *   **Mistral AI Integration:** ✅ *Analyzed*
        * **Initialization:**
            ```python
            from mistralai import Mistral
            api_key = os.environ.get("MISTRAL_API_KEY")
            mistral_client = Mistral(api_key=api_key)
            ```
        * **Model Selection:** Uses `mistral-tiny` for development/testing
        * **API Usage Pattern:**
            ```python
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message}
            ]
            stream_response = mistral_client.chat.stream(
                model="mistral-tiny",
                messages=messages
            )
            # Process streaming response
            response_content = ""
            for chunk in stream_response:
                if chunk.data.choices[0].delta.content is not None:
                    response_content += chunk.data.choices[0].delta.content
            ```
        * **Error Handling:** Fallback to rule-based responses if API unavailable
        * **Custom Prompting:** Structured prompts for flashcard generation
        * **Usage Metrics:** Tracking of token usage and latency
    *   **Multiplayer:** ✅ *Analyzed*
        * **Finding:** No multiplayer implementation found in current codebase
        * **No WebSocket Endpoints:** No `@app.websocket` routes in FastAPI code
        * **No Game State Management:** No lobby, player, or round management code
        * **No Real-time Communication:** No client-side WebSocket listeners
        * **Conclusion:** Multiplayer is a planned feature for the new stack rather than a migration requirement
        * **Implementation Plan:** Will use Supabase Realtime for WebSocket communication in the TypeScript version
3.  **Database Schema Design:** ✅ *Completed*
    *   **Core Tables & Columns:**
        * `user`:
          - `id` - varchar(36), PK, from Supabase Auth
          - `email` - varchar(256), unique, notNull
          - `createdAt` - timestamp with timezone
          - `updatedAt` - timestamp with timezone
        * `user_preference`:
          - `userId` - varchar(36), PK, FK to user.id
          - `prompt` - jsonb, stores prompt settings
          - `model` - jsonb, stores model settings
          - `context` - jsonb, stores context settings
          - `rag` - jsonb, stores RAG settings
          - `other` - jsonb, stores misc settings
          - `updatedAt` - timestamp with timezone
        * `flashcard`:
          - `id` - uuid, PK, auto-generated
          - `userId` - varchar(36), FK to user.id
          - `question` - text, notNull
          - `answer` - text, notNull
          - `title` - varchar(256), optional
          - `imageUrl` - varchar(2048), optional
          - `createdAt` - timestamp with timezone
          - `tags` - jsonb, array of string tags
          - `repetitions` - integer, default 0
          - `easeFactor` - real, default 2.5
          - `interval` - integer, default 1
          - `nextReview` - timestamp with timezone
          - `lastReview` - timestamp with timezone
          - `aiGenerated` - boolean, default false
        * `study_stat`:
          - `id` - serial, PK, auto-increment
          - `userId` - varchar(36), FK to user.id
          - `studiedToday` - integer, default 0
          - `totalStudied` - integer, default 0
          - `correctToday` - integer, default 0
          - `totalCorrect` - integer, default 0
          - `streak` - integer, default 0
          - `lastStudyDate` - timestamp with timezone
          - `updatedAt` - timestamp with timezone
        * `chat_session`:
          - `id` - uuid, PK, auto-generated
          - `userId` - varchar(36), FK to user.id
          - `title` - varchar(256), default "New Chat"
          - `createdAt` - timestamp with timezone
          - `updatedAt` - timestamp with timezone
        * `chat_message`:
          - `id` - uuid, PK, auto-generated
          - `sessionId` - uuid, FK to chat_session.id
          - `role` - varchar(20), notNull ('user'|'assistant'|'system')
          - `content` - text, notNull
          - `timestamp` - timestamp with timezone
          - `metrics` - jsonb, stores performance metrics
        * `feedback`:
          - `id` - serial, PK, auto-increment
          - `messageId` - uuid, FK to chat_message.id
          - `rating` - integer, notNull
          - `comments` - text, optional
          - `createdAt` - timestamp with timezone
        * `rag_collection`:
          - `id` - serial, PK, auto-increment
          - `name` - varchar(100), unique, notNull
          - `description` - text, optional
          - `createdAt` - timestamp with timezone
          - `updatedAt` - timestamp with timezone
        * `rag_document`:
          - `id` - serial, PK, auto-increment
          - `collectionId` - integer, FK to rag_collection.id
          - `content` - text, notNull
          - `metadata` - jsonb, document metadata
          - `createdAt` - timestamp with timezone
          - (Placeholder for vector embedding field)
        * `game_lobby`:
          - `id` - serial, PK, auto-increment
          - `code` - varchar(8), unique, notNull
          - `hostUserId` - varchar(36), FK to user.id
          - `status` - varchar(20), default "waiting"
          - `flashcardSetId` - uuid, optional
          - `createdAt` - timestamp with timezone
          - `updatedAt` - timestamp with timezone
        * `game_player`:
          - `id` - serial, PK, auto-increment
          - `lobbyId` - integer, FK to game_lobby.id
          - `userId` - varchar(36), FK to user.id
          - `nickname` - varchar(50), notNull
          - `score` - integer, default 0
          - `status` - varchar(20), default "joined"
          - `joinedAt` - timestamp with timezone
        * `game_round`:
          - `id` - serial, PK, auto-increment
          - `lobbyId` - integer, FK to game_lobby.id
          - `questionId` - uuid, FK to flashcard.id
          - `roundNumber` - integer, notNull
          - `startTime` - timestamp with timezone
          - `endTime` - timestamp with timezone
          - `status` - varchar(20), default "active"
        * `game_answer`:
          - `id` - serial, PK, auto-increment
          - `roundId` - integer, FK to game_round.id
          - `playerId` - integer, FK to game_player.id
          - `answerText` - text, notNull
          - `timeTaken` - integer, notNull (in milliseconds)
          - `isCorrect` - boolean, default false
          - `pointsAwarded` - integer, default 0
          - `submittedAt` - timestamp with timezone
    *   **Relationships & Constraints:**
        * One-to-many relationships with proper foreign keys
        * Cascading deletes to maintain referential integrity
        * Unique constraints on critical fields (email, game codes)
        * Compound unique constraints (lobbyId+userId, lobbyId+roundNumber, roundId+playerId)
        * Indexing on frequently queried fields and foreign keys
    *   **Data Types Selected:**
        * `uuid` for primary keys with high uniqueness requirements
        * `serial` for auto-incrementing IDs
        * `varchar` with appropriate lengths for shorter text
        * `text` for unbounded text content
        * `timestamp with timezone` for all date/time fields
        * `integer` for counters and scores
        * `real` for decimal values (ease factors)
        * `boolean` for flags
        * `jsonb` for flexible structured data (tags, metrics)
        * Placeholder for `vector` type when pgvector extension is enabled
    *   **Schema Implementation:**
        * Implemented in `src/server/db/schema.ts` using Drizzle ORM
        * Proper TypeScript typing for all schema elements
        * Relations defined for type-safe joins and queries
        * Table definitions applied to Supabase PostgreSQL
4.  **Tooling Setup:** ✅ *Completed*
    *   Integrate tRPC into the Next.js project. ✅ *Completed*
    *   Integrate Drizzle ORM and Drizzle Kit, configure connection to Supabase DB. ✅ *Completed*
    *   Set up a UI component library (e.g., Shadcn/ui + Tailwind CSS). ✅ *Tailwind and ShadcnUI installed*
    *   Set up a state management library (e.g., Zustand). ✅ *Installed*
    *   Configure Biome via `biome.json`. ✅ *Completed*
    *   Define `pnpm` scripts in `package.json`: `dev`, `build`, `start`, `typecheck`, `check`, `check:write`, `db:push`, `db:studio`. ✅ *Completed*
5.  **Code Style Enforcement:** Run `pnpm check:write` on the initial project setup to establish baseline formatting. ✅ *Completed*

**Phase 1: Core Backend & Data Foundation**

1.  **Implement Database Schema:** ✅ *Completed*
    *   Drizzle schema definitions written in `src/server/db/schema.ts` based on the design ✅ *Done*
    *   Schema applied to Supabase PostgreSQL using `pnpm db:push` ✅ *Done*
    *   Tables created with appropriate data types, constraints, and relationships ✅ *Done*
    *   Indexes added for performance optimization ✅ *Done*
2.  **Authentication Setup:** ✅ *Completed*
    *   Integrated Supabase Auth using `@supabase/ssr` and `@supabase/supabase-js` ✅ *Done*
    *   Implemented sign-up, login, logout flows with client components ✅ *Done*
    *   Added email and password validation with error handling ✅ *Done*
    *   Created middleware for route protection ✅ *Done*
    *   Built AuthProvider context for client-side auth state ✅ *Done*
    *   Added account synchronization between Auth and database ✅ *Done*
3.  **Basic tRPC Setup:** ✅ *Completed*
    *   Updated tRPC context to include authentication (`src/server/api/trpc.ts`) ✅ *Done*
    *   Added auth middleware and protectedProcedure ✅ *Done*
    *   Created user router (`src/server/api/routers/user.ts`) ✅ *Done*
    *   Implemented procedures for profile access and user synchronization ✅ *Done*
    *   Connected tRPC to the dashboard page for testing ✅ *Done*

**Phase 2: Port Backend Features to tRPC**

*   *(Standard for all procedures: Implement within tRPC routers (`src/server/api/routers/`). Use Drizzle for database operations. Use Zod for input validation (`.input(zodSchema)`). Adhere to async/await and camelCase naming. Ensure procedures requiring auth are protected.)*

1.  **Flashcard CRUD (`flashcards.ts` router):** ✅ *Completed*
    *   `createFlashcard`: Input Zod schema (question, answer, title?, image\_url?), insert into `flashcards` table associated with `ctx.session.user.id`. ✅ *Implemented*
    *   `getFlashcards`: Input Zod schema (optional filters/sorting), query user's flashcards. ✅ *Implemented*
    *   `updateFlashcard`: Input Zod schema (cardId, fields to update), update specific card owned by the user. ✅ *Implemented*
    *   `deleteFlashcard`: Input Zod schema (cardId), delete specific card owned by the user. ✅ *Implemented*
    *   Added deck management: `getDecks`, `createDeck`, `updateDeck`, `deleteDeck` ✅ *Implemented*
2.  **Flashcard Study Logic (`flashcards.ts` router):** ✅ *Completed*
    *   Port SM-2 algorithm logic to TypeScript functions. ✅ *Implemented*
    *   `getDueCards`: Query user's flashcards where `next_review <= NOW()` or `next_review IS NULL`. ✅ *Implemented*
    *   `getNewCards`: Query user's flashcards where `next_review IS NULL`. ✅ *Implemented*
    *   `recordStudyResult`: Input Zod schema (cardId, ease: 1|2|3|4). Implements SM-2 algorithm with interval/ease_factor/repetitions calculation. ✅ *Implemented*
    *   `getStudyStats`: Query `study_stats` table for the user. ✅ *Implemented*
    *   `updateStudyStats`: Update `study_stats` after a study session. ✅ *Implemented*
3.  **AI Flashcard Generation (`ai.ts` router):** ⏳ *Partially Implemented*
    *   Initial Router setup with provider selection. ✅ *Implemented*
    *   `getProviders`: Lists available AI model providers. ✅ *Implemented*
    *   `getModelsByProvider`: Gets models for a specific provider. ✅ *Implemented*
    *   `analyzeDifficulty`: Using flashcard data to identify challenging cards. ⏳ *To be implemented*
    *   `generateAiFlashcards`: Generate new flashcards based on difficult cards. ⏳ *To be implemented*
        *   Current implementation uses MockMistralClient instead of actual API calls. ⏳ *In progress*
4.  **Chat Service (`chat.ts` router):** ⏳ *Partially implemented and working*
    *   `createSession`: Creates new chat session with optional title. ✅ *Implemented*
    *   `getSession`: Retrieves a specific chat session. ❌ *Not working*
    *   `getSessions`: Lists all chat sessions for the user. ❌ *Not working*
    *   `updateSessionTitle`: Changes the title of an existing session. ❌ *Not working*
    *   `deleteSession`: Removes a chat session and all its messages. ⏳ *Not Tested*
    *   `getMessages`: Retrieves all messages from a specific session. ⏳ *Not Tested*
    *   `sendMessage`: Processes user message and returns AI response. ✅ *Implemented*
        *   Creates/fetches chat_session and history.
        *   Uses AIService to interact with the model.
        *   Saves both user and AI messages to database.
    *   `submitFeedback`: Stores user feedback (rating, comments) for messages. ⏳ *Not Tested*
5.  **RAG Integration:**
    *   **We will rebuild/replace RAG with Supabase Vector:** ⏳ *Not started*
        *   Enable `pgvector` extension in Supabase. Add `vector` column to `rag_documents` schema. ⏳ *Not implemented*
        *   Implement `createCollection` procedure (inserts into `rag_collections`). ⏳ *Not implemented*
        *   Implement `addDocument` procedure for document processing and embedding. ⏳ *Not implemented*
        *   Implement `retrieveContext` procedure for similarity search. ⏳ *Not implemented*
        *   Modify `sendMessage` procedure to call `retrieveContext`. ⏳ *Not implemented*
        *   Implement `getEmbeddings`, `retrieveAnswer` as needed. ⏳ *Not implemented*

**Important Tailwind CSS v4.0 Information:**

**IMPORTANT: THERE ARE NO TAILWIND CONFIGURATION FILES ANYMORE (NO tailwind.config.js). TAILWIND IS NOW CSS-FIRST.**

* **CSS Import:**
  ```css
  /* In your main CSS file (e.g., globals.css) */
  @import "tailwindcss";

  /* You can add your custom CSS and configuration here: */
  @layer base {
    :root {
      /* Define CSS variables for your design tokens */
      --color-primary: #3b82f6;
      --color-secondary: #10b981;
    }
  }

  /* Customize Tailwind via CSS */
  @layer components {
    .btn-primary {
      @apply px-4 py-2 bg-[var(--color-primary)] text-white rounded-md hover:opacity-90;
    }
  }
  ```

* **CSS-First Configuration:** All customizations should be directly in the CSS file where you import Tailwind, not in a separate config file.
  * Color schemes using CSS variables: `--color-primary`, `--color-secondary`, etc.
  * Custom breakpoints via `@media (min-width: 1280px) { /* styles */ }`
  * Custom components via `@layer components { .custom-component { /* styles */ } }`
  * Extend Tailwind's utilities via `@layer utilities { .custom-utility { /* styles */ } }`

* **Style Guidelines:**
  * Use Tailwind utility classes for all styling needs
  * **AVOID INLINE STYLES UNLESS ABSOLUTELY MANDATORY**
  * Group related utility classes logically
  * Extract repeated patterns into components using `@layer components`
  * Use meaningful class names for custom components
  * Leverage CSS variables for design tokens
  * Use arbitrary value syntax for custom values: `w-[32rem]`, `text-[#336699]`, etc.
  * Prefer semantic utility composition over custom CSS when possible

**Phase 3: Frontend Foundation**

1.  **Basic Layout & Navigation:** ✅ *Completed*
    *   Set up `app/layout.tsx` with providers (tRPC, State Management, Supabase Auth). ✅ *Implemented*
    *   Implement a persistent sidebar or tabbed navigation component. ✅ *Implemented*
    *   Integrate chosen UI library (Tailwind, Shadcn/ui components). ✅ *Implemented*
2.  **Authentication UI:** ⏳ *Partially Implemented*
    *   Build Login (`app/login/page.tsx`), Sign Up (`app/signup/page.tsx`) pages/components. ✅ *Implemented*
    *   UI and form validation implemented, but using mock authentication. ⏳ *In progress*
    *   Missing full integration with Supabase Auth. ⏳ *To be completed*
3.  **State Management Setup:** ✅ *Completed*
    *   Integrate Zustand. Create initial stores (`src/stores/`) for settings. ✅ *Implemented*
4.  **tRPC Client Setup:** ✅ *Completed*
    *   Configure tRPC client provider (`src/trpc/react.tsx`). ✅ *Implemented*
    *   Added enhanced error handling and debugging in the tRPC client. ✅ *Implemented*

**Phase 4: Port Frontend Features**

*   *(Standard for all components: Create components in `src/components/`. Use PascalCase. Use tRPC hooks (`api.router.procedure.useQuery`, `api.router.procedure.useMutation`) for data fetching/mutation. Use state management library (Zustand) for shared/complex UI state. Apply UI library styles. Use Zod for any client-side form validation.)*

1.  **Settings UI (`app/settings/page.tsx`):** ⏳ *Partially Implemented*
    *   UI components and tab structure implemented. ✅ *Implemented*
    *   Using mock data instead of actual tRPC queries. ⏳ *To be completed*
    *   Missing proper connection to tRPC backend. ⏳ *To be completed*
    *   RAG collection management UI not implemented. ⏳ *Not started*
2.  **Flashcard UI (Study - `app/flashcards/study/[deck]/page.tsx`):** ✅ *Completed*
    *   `FlashcardDisplay` component created. ✅ *Implemented*
    *   Study interface with proper tRPC queries and mutations. ✅ *Implemented*
    *   "Show Answer" button with state management. ✅ *Implemented*
    *   Rating buttons (Again, Hard, Good, Easy) using SM-2 algorithm. ✅ *Implemented*
    *   Proper error handling and loading states. ✅ *Implemented*
3.  **Flashcard UI (Create/Manage):** ✅ *Completed*
    *   **Create (`app/flashcards/create/page.tsx`):** ✅ *Implemented*
        *   Form with proper validation and tRPC mutations.
        *   Deck selection and creation.
    *   **Manage (`app/flashcards/manage/[deck]/page.tsx`):** ✅ *Implemented*
        *   List view with filtering/sorting.
        *   Full CRUD operations with tRPC mutations.
        *   Edit and delete functionality.
    *   **Stats page:** ⏳ *Not implemented*
4.  **AI Assistant UI (`app/flashcards/ai-assistant/page.tsx`):** ⏳ *Not implemented*
    *   Backend has basic AI router, but not the full functionality. ⏳ *Not started*
    *   UI not implemented yet. ⏳ *Not started*
5.  **Chat UI (`app/chat/page.tsx` and `app/chat/[sessionId]/page.tsx`):** ✅ *Completed*
    *   `ChatMessage` component for displaying messages. ✅ *Implemented*
    *   Chat history with proper tRPC queries. ⏳ *In progress*
    *   Chat input with message sending. ✅ *Implemented*
    *   Session management (create, delete, rename). ❌ *Not working*
    *   Streaming responses from AI models. ✅ *Implemented*
    *   **Chat Sidebar:** ✅ *Implemented*
        *   Session management UI.
        *   Create, edit, delete chat sessions.
        *   Enhanced error handling with detailed logs.

**Phase 5: Multiplayer Implementation**

1.  **Database Schema for Multiplayer:** ✅ *Completed*
    *   Added game-related tables to schema: ✅ *Implemented*
        *   `game_lobby`: Stores game session data with code and host
        *   `game_player`: Tracks participants with scores and status
        *   `game_round`: Manages individual rounds with questions
        *   `game_answer`: Records player responses with timing and scoring
    *   Tables created in database with proper relationships and constraints. ✅ *Implemented*
2.  **Backend (Realtime & tRPC):** ⏳ *Not implemented*
    *   Supabase Realtime setup. ⏳ *Not started*
    *   tRPC procedures for game management. ⏳ *Not started*
    *   Realtime events and broadcast system. ⏳ *Not started*
3.  **Frontend (Multiplayer UI - `app/multiplayer/...`):** ⏳ *Partially implemented*
    *   **Lobby (`app/multiplayer/lobby/[id]/page.tsx`):** ⏳ *UI only*
        *   UI implemented with player list, game settings, code sharing. ✅ *Implemented*
        *   Using mock data instead of real backend connections. ⏳ *To be completed*
        *   Start game functionality with simulated network requests. ⏳ *To be completed*
    *   **Game Play (`app/multiplayer/clash/[id]/page.tsx`):** ⏳ *UI only*
        *   UI implemented with question display, timer, scoring. ✅ *Implemented*
        *   Using client-side simulations and mock data. ⏳ *To be completed*
        *   No real backend integration or multiplayer functionality. ⏳ *To be completed*
    *   **Results View:** ⏳ *UI only*
        *   Basic UI for displaying game results. ✅ *Implemented*
        *   Using mock data instead of actual game results. ⏳ *To be completed*

**Phase 6: Testing & Refinement**

1.  **Unit Testing:** ⏳ *Not implemented*
    *   No test setup or test files in the codebase. ⏳ *Not started*
    *   No test libraries installed (Jest, Vitest). ⏳ *Not started*
2.  **Integration Testing:** ⏳ *Not implemented*
    *   No integration tests for tRPC procedures. ⏳ *Not started*
3.  **End-to-End Testing:** ⏳ *Not implemented*
    *   No E2E testing setup (Cypress, Playwright). ⏳ *Not started*
4.  **Code Quality Checks:** ✅ *Completed*
    *   Using Biome for linting and formatting. ✅ *Implemented*
    *   TypeScript for type checking. ✅ *Implemented*
    *   Scripts defined in `package.json`: `check`, `check:write`, `typecheck`. ✅ *Implemented*
5.  **UI/UX Refinement:** ⏳ *In progress*
    *   Basic responsive design with Tailwind CSS. ✅ *Implemented*
    *   Loading states and error handling in many components. ⏳ *In progress*
    *   Enhanced error reporting in tRPC client. ✅ *Implemented*
6.  **Performance Optimization:** ⏳ *Not implemented*
    *   No specific performance optimizations. ⏳ *Not started*
7.  **Security Review:** ⏳ *Not implemented*
    *   Authentication partially implemented. ⏳ *In progress*
    *   Supabase RLS policies not visible in codebase. ⏳ *Not started*
8.  **Documentation:** ⏳ *In progress*
    *   CLAUDE.md with migration plan. ✅ *Implemented*
    *   README.md needs updates with setup instructions. ⏳ *To be done*

**Important Next.js 15+ Implementation Notes:**

1. **Route Parameters with React.use():**
   * In Next.js 15.2.4+, route parameters are Promises that must be unwrapped with `React.use()`.
   * Warning: "A param property was accessed directly with `params.id`. `params` is now a Promise..."
   * Correct usage:
     ```tsx
     // Page component with dynamic route params
     export default function PageComponent({ params }: { params: { id: string } }) {
       const unwrappedParams = React.use(params);
       return <ChildComponent id={unwrappedParams.id} />;
     }
     ```
   * Direct access may work now but could break in future versions or cause re-render issues.
   * Use proper TypeScript typing for safe parameter handling.

**Phase 7: Deployment & Monitoring**

1.  **Deployment:** ⏳ *Not implemented*
    *   Configure Vercel project, link GitHub repository. ⏳ *Not started*
    *   Set up production environment variables. ⏳ *Not started*
    *   Configure Supabase project for production. ⏳ *Not started*
    *   Deployment setup. ⏳ *Not started*
2.  **CI/CD:** ⏳ *Not implemented*
    *   No GitHub Actions workflow or other CI/CD setup. ⏳ *Not started*
    *   No automated testing or build pipeline. ⏳ *Not started*
3.  **Monitoring & Logging:** ⏳ *Partially implemented*
    *   Enhanced logging in tRPC client for debugging. ✅ *Implemented*
    *   Detailed error handling in API routes. ✅ *Implemented*
    *   No production monitoring setup. ⏳ *Not started*

**Project Progress Summary**

1. **Core Database Implementation:** ✅ *Completed (100%)*
   * Schema design and migration ✅
   * Drizzle ORM integration ✅
   * Database schema optimizations ✅
   * Relations and constraints ✅

2. **Backend API (tRPC):** ⏳ *Mostly complete (60%)*
   * Chat API (partial) ⏳
   * Flashcard CRUD and study API ✅
   * User authentication (partial) ⏳
   * AI integration (partial) ⏳
   * RAG implementation missing ❌

3. **Frontend Components:** ⏳ *Partially complete (60%)*
   * Layout and navigation ✅
   * Chat UI ✅
   * Flashcard Create/Manage/Study ✅
   * Settings UI (mock data) ⏳
   * Authentication UI (partial) ⏳
   * AI Assistant UI missing ❌

4. **Multiplayer Features:** ⏳ *Early stage (30%)*
   * Database schema ✅
   * UI components with mock data ⏳
   * Backend integration missing ❌
   * Real-time functionality missing ❌

5. **Testing and Polish:** ⏳ *Early stage (20%)*
   * Code quality checks ✅
   * Error handling improvements ⏳
   * No formal testing ❌
   * No deployment pipeline ❌

**Key Considerations & Next Steps:**

*   **Authentication Completion:** Integrate the authentication UI with Supabase Auth backend.
*   **AI Integration:** Finish implementing the Mistral AI integration for flashcard generation.
*   **RAG Implementation:** Add pgvector extension and implement document embedding/search.
*   **Multiplayer Backend:** Implement the tRPC procedures for game management and Supabase Realtime channels.
*   **Testing:** Set up testing framework and write tests for critical components.
*   **Deployment:** Configure deployment pipeline for production environment.
*   **Documentation:** Update README.md with setup instructions and architecture overview.
